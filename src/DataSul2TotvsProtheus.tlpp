#define DTS_DBS_NAME   1
#define DTS_DBS_TYPE   2
#define DTS_DBS_FLG    3
#define DTS_DBS_FORMAT 4

#define DTS_DBS_ALEN   4

#include "totvs.ch"
#include "shell.ch"

#include "dbstruct.ch"

#include "jsonhash.ch"
#include "jsonarray.ch"

namespace datasul2totvs

#include "execin.th"
EXECIN CLASS datasul2totvs

static function GetValue(xVar as variant,xDefault as variant) as variant
return(cacheData():Get("datasul2totvsprotheus",xVar,xDefault))

static function SetValue(xVar as variant,xValue as variant) as variant
return(cacheData():Set("datasul2totvsprotheus",xVar,xValue))

static function DelProperty(xProperty as variant) as variant
return(cacheData():delProperty("datasul2totvsprotheus",xProperty))

static function DelSection(xSection as variant) as variant
    dfv():Default(@xSection,"datasul2totvsprotheus")
return(cacheData():delSection(xSection))

static function EvalBlockGetValue(xVar as variant,xDefault as variant) as variant
return(cacheData():Get("EvalBlock",xVar,xDefault))

static function GetHMValue(xVar as variant,xDefault as variant) as variant
return(cacheHMData():Get(xVar,xDefault))

static function SetHMValue(xVar as variant,xValue as variant) as variant
return(cacheHMData():Set(xVar,xValue))

static function DelHMValue(xVar as variant) as variant
return(cacheHMData():Del(xVar))

static function CleanHMData() as variant
return(cacheHMData():Clean())

class Protheus
    static method Activate() as logical
end class

static method Activate() class Protheus

    local lActivate as logical
    local lSetCentury:=__SetCentury("ON") as logical
    local nSetVarNameLen:=SetVarNameLen(Max(SetVarNameLen(),254))
    local oException as object

    private cCadastro:="TOTVS :: DataSul To Protheus" as character

    begin sequence

        lActivate:=((FWIsAdmin(__cUserID)).and.(GetNewPar("TOTVSDS2PT",.T.)))
        if (!lActivate)
            if (getComputerName()$"DNA-CSDJ-01")
                lActivate:=DNAMainExec():Execute("dna.main.exec.MyIsAdmin")
            endif
            if (!lActivate)
                ApMsgAlert("User without administrative privileges")
                break
            endif
        endif

        lActivate:=DTS2PTProc():Execute("DNAChkAuth")
        if (!lActivate)
            break
        endif

        lActivate:=datasul2totvs.Activate()

    end sequence

    FWMsgRun(nil,{||cacheData():Clean(),cacheHMData():Clean()},"Wait...","Releasing temporary files and workspace memory...")

    try
        //Tenta Resetar todos os filtros
        CleanAllFilter()
    catch oException
        //Ocorreram problemas no Reset
        FreeObj(@oException)
    endtry

    __SetCentury(if(lSetCentury,"ON","OFF"))
    SetVarNameLen(nSetVarNameLen)

return(lActivate)

static function Activate() as logical

    local aMenu as array
    local aMenuItems as array
    local aStack:={"DATASUL2TOTVS.ACTIVATE","ACTIVATE","U_DATASUL2TOTVSPROTHEUS"} as array
    local aSections as array
    local aProperties as array

    local bTMenuAction as codeblock

    local cAlias as character
    local cSection as character
    local cProperty as character
    local cTMenuAction as character
    local cGetFileRoot:="\" as character
    local cGetFileMask as character
    local cGetFileTitle as character

    local lFastMode as logical
    local lPercentage as logical

    local lActivate as logical
    local lSendDataToServer as logical
    local lRedefineBottom:=FwIsInCallStack("DNA.MAIN.EXEC.EXECUTE") as logical

    local nSection as numeric
    local nSections as numeric
    local nProperty as numeric
    local nProperties as numeric
    local nGetFileOptions as numeric

    local oTDlg as object
    local oTMenu as object
    local oFWDefSize as object

    local oTFIni as object

    local oTMenuItem as object
    local oTMenuOptions as object

    begin sequence

        lActivate:=stacktools():IsInStackCall(aStack)
        if (!lActivate)
            break
        endif

        lActivate:=DTS2PTProc():Execute("DNAChkAuth")
        if (!lActivate)
            break
        endif

        private st_oHMbTransform:=THashMap():New() as object

        lSendDataToServer:=(;
            (getComputerName()$(GetNewPar("TOTVSD2PCN","DNA-CSDJ-01")));
            .and.;
            (ApMsgNoYes("Sending Data To Server?"));
        )

        if (lSendDataToServer)
            FWMsgRun(nil,{||lSendDataToServer:=datasul2totvs.sendDataToServer(@cGetFileRoot,.F.)},"Wait!","Sending Data To Server")
        elseif (file("\datasul2Protheus\ini\DataSul2Protheus.ini"))
            cGetFileRoot:="SERVIDOR\datasul2protheus\ini\"
        endif

        cGetFileMask:=cTools():Accentuation("Arquivo de Configura#1#2o | DataSul2Protheus.ini","ccedil","atilde")
        cGetFileTitle:=cTools():Accentuation("Arquivo de Configura#1#2o DataSul2Protheus.ini","ccedil","atilde")

        nGetFileOptions:=(GETF_LOCALHARD+GETF_NETWORKDRIVE)

        cINIFile:=cGetFile(;
            cGetFileMask,;
            cGetFileTitle,;
            1,;
            cGetFileRoot,;
            .F.,;
            nGetFileOptions,;
            /*[lArvore]*/,;
            /*[lKeepCase]*/;
        )

        lActivate:=file(cINIFile)
        if (!lActivate)
            ApMsgAlert("Configuration file invalid ["+cINIFile+"] or not found","Attention")
            break
        endif

        lActivate:=("datasul2protheus.ini"$lower(cINIFile))
        if (!lActivate)
            ApMsgAlert("Configuration file invalid ["+cINIFile+"] or not found","Attention")
            break
        endif

        FWMsgRun(nil,{||lActivate:=datasul2totvs.readIniFile(@cINIFile)},"Wait! Loading Settings","["+cINIFile+"]")
        if (!lActivate)
            break
        endif

        FWMsgRun(nil,{||lActivate:=datasul2totvs.readTableDefinition()},"Loading structure of tables","Wait...")
        if (!lActivate)
            break
        endif

        oTFIni:=GetValue("readIniFile")

        lActivate:=(allTrim(oTFIni:GetPropertyValue("General","CompanyCode","@@"))==&("cEmpAnt"))
        if (!lActivate)
            ApMsgAlert("The import process cannot be performed for the Selected Company ["+&("cEmpAnt")+"]","Attention")
            break
        endif

        lFastMode:=(allTrim(oTFIni:GetPropertyValue("General","IncProcFastMode","0"))=="1")
        lPercentage:=(allTrim(oTFIni:GetPropertyValue("General","IncProcPercentage","0"))=="1")

        oFWDefSize:=FWDefSize():New(.T.,.T.)//Sem enchoicebar
        oFWDefSize:lLateral:=.F.//Calculo vertical
        oFWDefSize:AddObject("TMENU",100,100,.T.,.T.)//TMENU

        oFWDefSize:Process()

        nTop:=oFWDefSize:aWindSize[1]
        nLeft:=oFWDefSize:aWindSize[2]
        nBottom:=oFWDefSize:aWindSize[3]
        nRight:=oFWDefSize:aWindSize[4]

        if (lRedefineBottom)
            nBottom-=50
        endif

        oTMenuOptions:=Array(#)

        aMenu:=aClone(oTFIni:GetAllProperties("Menu"))
        nSections:=Len(aMenu)
        for nSection:=1 to nSections
            cSection:=aMenu[nSection][HASH_PROPERTY_KEY]
            aMenuItems:=cTools():StrTokArray(oTFIni:GetPropertyValue("Menu",cSection),",")
            oTMenuOptions[#cSection]:=Array(#)
            oTMenuOptions[#cSection][#"Alias"]:=Array(#)
            nProperties:=Len(aMenuItems)
            for nProperty:=1 to nProperties
                oTMenuOptions[#cSection][#"Alias"][#StrZero(nProperty,2)]:=aMenuItems[nProperty]
            next nProperty
            FWFreeArray(@aMenuItems)
        next nSection

        FWFreeArray(@aMenuItems)
        FWFreeArray(@aMenu)

        DEFINE MSDIALOG oTDlg TITLE cCadastro FROM nTop,nLeft TO nBottom,nRight PIXEL OF getWNDDefault()

            if (lRedefineBottom)
                oTDlg:nTop+=7
                oTDlg:nLeft+=5
                oTDlg:nRight+=0
                oTDlg:nBottom-=11
            endif

            MENU oTMenu IMAGE "" OF oTDlg
                MENUITEM cCadastro
                MENU
                    aSections:=aClone(oTMenuOptions:GetAllSections())
                    nSections:=Len(aSections)
                    for nSection:=1 to nSections
                        cSection:=aSections[nSection]
                        aProperties:=aClone(oTMenuOptions[#cSection][#"Alias"]:GetAllSections())
                        nProperties:=Len(aProperties)
                        MENUITEM cSection
                        MENU
                            for nProperty:=1 to nProperties
                                cProperty:=aProperties[nProperty]
                                cAlias:=oTMenuOptions[#cSection][#"Alias"][#cProperty]
                                beginContent var cTMenuAction
                                    {||datasul2totvs.ProcImportData("cAlias",lPercentage,lFastMode)}
                                endContent
                                cTMenuAction:=cTools():StrReplace(;
                                    cTMenuAction,;
                                    {CRLF,""},;
                                    {CHR(10),""},;
                                    {CHR(13),""},;
                                    {" ",""},;
                                    {"cAlias",cAlias},;
                                    {"lPercentage",IF(lPercentage,".T.",".F.")},;
                                    {"lFastMode",IF(lFastMode,".T.",".F.")};
                                )
                                bTMenuAction:=&(cTMenuAction)
                                cTMenuAction:=""
                                MENUITEM oTMenuItem PROMPT cAlias+" :: "+Upper(FWSX2Util():GetX2Name(cAlias,.F.))
                                oTMenuItem:bAction:=bTMenuAction
                            next nProperty
                        ENDMENU
                        FWFreeArray(@aProperties)
                    next nSection
                    FWFreeArray(@aSections)
                    oTMenuOptions:FreeObj()
                    FreeObj(@oTMenuOptions)
                ENDMENU
                MENUITEM "Tools"
                MENU
                    MENUITEM oTMenuItem PROMPT "Send data to the server"
                    bTMenuAction:={||FWMsgRun(nil,{||lSendDataToServer:=datasul2totvs.sendDataToServer(@cGetFileRoot,.T.)},"Wait!","Sending Data To Server")}
                    oTMenuItem:bAction:=bTMenuAction
                    MENUITEM oTMenuItem PROMPT "Settings"
                    oTMenuItem:bAction:={||CFGFile()}
                    MENUITEM oTMenuItem PROMPT "Show Datasul Files"
                    oTMenuItem:bAction:={||ShowDatasulFiles()}
                    if (oTFIni:ExistSection("SplitFiles"))
                        oTMenuOptions:=Array(#)
                        aMenu:=aClone(oTFIni:GetAllProperties("SplitFiles"))
                        nSections:=Len(aMenu)
                        for nSection:=1 to nSections
                            cSection:=aMenu[nSection][HASH_PROPERTY_KEY]
                            aMenuItems:=cTools():StrTokArray(oTFIni:GetPropertyValue("SplitFiles",cSection),",")
                            oTMenuOptions[#cSection]:=Array(#)
                            oTMenuOptions[#cSection][#"Alias"]:=Array(#)
                            nProperties:=Len(aMenuItems)
                            for nProperty:=1 to nProperties
                                oTMenuOptions[#cSection][#"Alias"][#StrZero(nProperty,2)]:=aMenuItems[nProperty]
                            next nProperty
                            FWFreeArray(@aMenuItems)
                        next nSection
                        FWFreeArray(@aMenuItems)
                        FWFreeArray(@aMenu)
                        MENUITEM "Split Files"
                        MENU
                            MENUITEM "Split"
                            MENU
                                aSections:=aClone(oTMenuOptions:GetAllSections())
                                nSections:=Len(aSections)
                                for nSection:=1 to nSections
                                    cSection:=aSections[nSection]
                                    aProperties:=aClone(oTMenuOptions[#cSection][#"Alias"]:GetAllSections())
                                    nProperties:=Len(aProperties)
                                    MENUITEM cSection+" :: "+Upper(FWSX2Util():GetX2Name(cSection,.F.))
                                    MENU
                                        for nProperty:=1 to nProperties
                                            cProperty:=aProperties[nProperty]
                                            cAlias:=oTMenuOptions[#cSection][#"Alias"][#cProperty]
                                            beginContent var cTMenuAction
                                                {||FWMsgRun(nil,{||datasul2totvs.SplitFileAdd("cSourceFile")},"cMsgTitle","cMsgDetail")}
                                            endContent
                                            cTMenuAction:=cTools():StrReplace(;
                                                cTMenuAction,;
                                                {CRLF,""},;
                                                {CHR(10),""},;
                                                {CHR(13),""},;
                                                {" ",""},;
                                                {"cSourceFile",cAlias},;
                                                {"cMsgTitle","Wait, splitting files"},;
                                                {"cMsgDetail","["+cAlias+"]"};
                                            )
                                            bTMenuAction:=&(cTMenuAction)
                                            cTMenuAction:=""
                                            MENUITEM oTMenuItem PROMPT cAlias
                                            oTMenuItem:bAction:=bTMenuAction
                                        next nProperty
                                    ENDMENU
                                    FWFreeArray(@aProperties)
                                next nSection
                                FWFreeArray(@aSections)
                            ENDMENU
                            MENUITEM "Remove"
                            MENU
                                aSections:=aClone(oTMenuOptions:GetAllSections())
                                nSections:=Len(aSections)
                                for nSection:=1 to nSections
                                    cSection:=aSections[nSection]
                                    aProperties:=aClone(oTMenuOptions[#cSection][#"Alias"]:GetAllSections())
                                    nProperties:=Len(aProperties)
                                    MENUITEM cSection+" :: "+Upper(FWSX2Util():GetX2Name(cSection,.F.))
                                    MENU
                                        for nProperty:=1 to nProperties
                                            cProperty:=aProperties[nProperty]
                                            cAlias:=oTMenuOptions[#cSection][#"Alias"][#cProperty]
                                            beginContent var cTMenuAction
                                                {||FWMsgRun(nil,{||datasul2totvs.SplitFileDel("cSourceFile")},"cMsgTitle","cMsgDetail")}
                                            endContent
                                            cTMenuAction:=cTools():StrReplace(;
                                                cTMenuAction,;
                                                {CRLF,""},;
                                                {CHR(10),""},;
                                                {CHR(13),""},;
                                                {" ",""},;
                                                {"cSourceFile",cAlias},;
                                                {"cMsgTitle","Wait, removing files"},;
                                                {"cMsgDetail","["+cAlias+"]"};
                                            )
                                            bTMenuAction:=&(cTMenuAction)
                                            cTMenuAction:=""
                                            MENUITEM oTMenuItem PROMPT cAlias
                                            oTMenuItem:bAction:=bTMenuAction
                                        next nProperty
                                    ENDMENU
                                    FWFreeArray(@aProperties)
                                next nSection
                                FWFreeArray(@aSections)
                            ENDMENU
                            MENUITEM "Show"
                            MENU
                                aSections:=aClone(oTMenuOptions:GetAllSections())
                                nSections:=Len(aSections)
                                for nSection:=1 to nSections
                                    cSection:=aSections[nSection]
                                    aProperties:=aClone(oTMenuOptions[#cSection][#"Alias"]:GetAllSections())
                                    nProperties:=Len(aProperties)
                                    MENUITEM cSection+" :: "+Upper(FWSX2Util():GetX2Name(cSection,.F.))
                                    MENU
                                        for nProperty:=1 to nProperties
                                            cProperty:=aProperties[nProperty]
                                            cAlias:=oTMenuOptions[#cSection][#"Alias"][#cProperty]
                                            beginContent var cTMenuAction
                                                {||FWMsgRun(nil,{||datasul2totvs.SplitFileView("cSourceFile")},"cMsgTitle","cMsgDetail")}
                                            endContent
                                            cTMenuAction:=cTools():StrReplace(;
                                                cTMenuAction,;
                                                {CRLF,""},;
                                                {CHR(10),""},;
                                                {CHR(13),""},;
                                                {" ",""},;
                                                {"cSourceFile",cAlias},;
                                                {"cMsgTitle","Wait, showing files"},;
                                                {"cMsgDetail","["+cAlias+"]"};
                                            )
                                            bTMenuAction:=&(cTMenuAction)
                                            cTMenuAction:=""
                                            MENUITEM oTMenuItem PROMPT cAlias
                                            oTMenuItem:bAction:=bTMenuAction
                                        next nProperty
                                    ENDMENU
                                    FWFreeArray(@aProperties)
                                next nSection
                                FWFreeArray(@aSections)
                            ENDMENU
                            oTMenuOptions:FreeObj()
                            FreeObj(@oTMenuOptions)
                        ENDMENU
                    endif
                ENDMENU
                MENU
                    MENUITEM "Exit" ACTION if(ApMsgNoYes("Deseja sair?"),oTDlg:End(),.F.)
                ENDMENU
            ENDMENU

            oTMenu:align:=CONTROL_ALIGN_ALLCLIENT
            oTDlg:SetMenu(oTMenu)
            oTDlg:lCentered:=(!lRedefineBottom)

        ACTIVATE DIALOG oTDlg

        if (valType(oTMenuOptions)=="O")
            FWMsgRun(nil,{||oTMenuOptions:FreeObj()},"Wait...","Releasing temporary files and workspace memory...")
            FreeObj(@oTMenuOptions)
        endif

        FreeObj(@oTMenuItem)
        FreeObj(@oTMenu)
        FreeObj(@oTDlg)

    end sequence

    if (valType(oTFIni)=="O")
        FWMsgRun(nil,{||oTFIni:FreeObj()},"Wait...","Releasing temporary files and workspace memory...")
        if (valType(oTFIni)=="O")
            FreeObj(@oTFIni)
        endif
    endif

    FWFreeArray(@aStack)
    FWFreeArray(@aSections)
    FWFreeArray(@aProperties)

    FWMsgRun(nil,{||DelSection(),CleanHMData()},"Wait...","Releasing temporary files and workspace memory...")

    if (findFunction("RstPosAlias"))
        RstPosAlias()
    endif

    if (valType(st_oHMbTransform)=="O")
        FWMsgRun(nil,{||st_oHMbTransform:Clean()},"Wait...","Releasing temporary files and workspace memory...")
        FreeObj(@st_oHMbTransform)
    endif

    DelClassIntF()

return(lActivate)

static function ProcImportData(cAlias as character,lPercentage as logical,lFastMode as logical) as logical

    local aByRef as array

    local bProcImportData as codeblock

    local cMsgProcImportData as character

    local lEnd as logical
    local lEvalOK as logical
    local lImportData as logical

    local oTFont as object
    local oParameters:=Array(#) as object
    local oMSNewProcess as object

    cMsgProcImportData:="Importing :: "
    cMsgProcImportData+=cAlias
    cMsgProcImportData+=" :: "
    cMsgProcImportData+=Upper(FWSX2Util():GetX2Name(cAlias,.F.))
    cMsgProcImportData+=" :: ["+DToC(Date())+"]["+Time()+"]"

    oTFont:=TFont():New("Courier New",nil,14,nil,.F.)
    bProcImportData:={||;
        datasul2totvs.ProcRedefine(;
            oMSNewProcess,;
            @oTFont,;
            0,;
            850,;
            850,;
            .T.,;
            .T.,;
            lPercentage,;
            lFastMode;
        ),;
        lImportData:=ExecIn():evalJSONArrayObject(@oParameters,@aByRef,@lEvalOK);
    }
    oMSNewProcess:=MsNewProcess():New(bProcImportData,cMsgProcImportData,"Wait!",.T.)

    oParameters[#"ClassName"]:=cAlias+"Import"
    oParameters[#"FunctionName"]:=cAlias+"ImportData"
    oParameters[#"FunctionParameters"]:=Array(#)
    oParameters[#"FunctionParameters"][#"oMSNewProcess"]:=oMSNewProcess
    oParameters[#"FunctionParameters"][#"lEnd"]:=lEnd
    oParameters[#"FunctionParameters"][#"lPercentage"]:=lPercentage

    oMSNewProcess:Activate()

    if (lEvalOK)
        lEnd:=aByRef[2]
    else
        lImportData:=.F.
    endif

    oParameters[#"ClassName"]:=nil
    oParameters[#"FunctionName"]:=nil
    oParameters[#"FunctionParameters"][#"oMSNewProcess"]:=nil
    oParameters[#"FunctionParameters"][#"lEnd"]:=nil
    oParameters[#"FunctionParameters"]:FreeObj()

    oParameters:FreeObj()
    if (valType(oParameters)=="O")
        FreeObj(@oParameters)
    endif

    FreeObj(@oTFont)
    FreeObj(@oMSNewProcess)

    FWFreeArray(@aByRef)

    DelClassIntF()

return(lImportData)

static function ImportData(oMsNewProcess as object,lEnd as logical,lPercentage as logical,oTLogReport as object,cAlias as character,cIndexKey as character,cTableImport as character,aAddIndex as array,lPreLoadTable as logical,bCustomUpdate as codeblock) as logical

    local aLine as array
    local aField as array
    local aIncProcStep as array

    local aFieldsDef:=array(0) as array

    local aSourceTmpFields as array
    local aSourceTmpFldStruct as array

    local aDataPathSplit as array

    local aTargetStruct:=(cAlias)->(dbStruct()) as array
    local aTargetFieldsDef as array
    local aReplicateValues as array
    local aNoReplicateValues as array
    local aTargetFieldsDefTmp as array
    local aTargetReplicateFields as array
    local aTargetReplicateFieldsPos as array
    local aTargetFieldsDefReplicate as array

    local aUpdateTableFields as array
    local aUpdateTableSource as array

    local bAddTLogReport as codeblock
    local bDeleteIfEmpty as codeblock
    local bAfterUpdateRecNo as codeblock
    local bAfterUpdateTable as codeblock
    local bUpdateMemoVirtual as codeblock
    local bTargetIgnoreFields as codeblock

    local bSourceGetLine as codeblock
    local bSourceSetFilter as codeblock
    local bSourceAppendLine as codeblock
    local bEnableFilterBlock as codeblock
    local bEnableFilterBlockMem as codeblock

    local cCRLF:=CRLF as character
    local cError as character
    local cField as character

    local cSourceAlias:=getNextAlias() as character
    local cTargetAlias:=cAlias as character
    local cTargetIgnoreFields as character
    local cTargetAliasRealName as character

    local cType as character

    local cLine as character
    local cDataPath as character
    local cSourceFile as character
    local cSourceTable as character
    local cDataPathSplit as character

    local cNoReplicateValues as character

    local cSVFilAnt:=&("cFilAnt") as character

    local cRecCount as character

    local cTime as character

    local cTLogGroup as character
    local cTLogDetail as character

    local cIndexID as character
    local cFieldFilial as character
    local cAliasxFilial as character

    local cIncProc as character
    local cTimeRemaining as character

    local cSeekTable as character
    local cSeekIndexKey as character
    local cSeekTableIndex as character
    local cAllSeekIndexKey as character
    local cUpdateTableFields as character
    local cUpdateTableSource as character

    local cFWTemporaryTableRealName as character

    local cFieldsFilterBlock as character

    local cGetFileMask as character
    local cGetFileTitle as character

    local lLock as logical
    local lFound as logical
    local lAddNew as logical
    local lAppend as logical
    local ldbCommit as logical
    local lSetRegua:=.T. as logical
    local lHasError:=.F. as logical
    local lChkFilial as logical
    local lChkEncode as logical
    local lAskUpdate as logical
    local lSeekTable as logical
    local lImportData as logical
    local lMemoVirutal as logical
    local lAddFieldTmp as logical
    local lFilterBlock as logical
    local lCustomUpdate:=.F. as logical
    local lTypeReplicate:=.F. as logical
    local lDeleteIfEmpty as logical
    local lSeekTableFound as logical
    local lTCSQLUpdateTable as logical
    local lTypeReplicateRow as logical
    local lTablesEncodeUTF8 as logical
    local lAfterUpdateRecNo:=.F. as logical
    local lAppendIfNotExist as logical
    local lUpdateEmptyValue:=.F. as logical
    local lUpdateTableFields:=.F. as logical
    local lEnableFilterBlock as logical

    local lDeleted:=Set(_SET_DELETED,"ON") as logical

    local nField as numeric
    local nFields as numeric

    local nReplicate as numeric
    local nReplicates:=0 as numeric

    local nEndLine as numeric
    local nStartLine as numeric

    local nRecProc:=0 as numeric
    local nSetRegua:=0 as numeric
    local nRecCount as numeric
    local nRecProcPerc as numeric
    local nRecCountProc as numeric
    local nCommitBuffer as numeric
    local nRecProcCustom as numeric
    local nTargetFieldAT as numeric
    local nTargetFieldPos as numeric

    local nGetFileOptions as numeric

    local nReplicateValuesAT as numeric

    local nIndexKey as numeric
    local nSeekTableIndex as numeric
    local nUpdateTableSource as numeric

    local nFieldFilial as numeric

    local nIncProcStep as numeric

    local nDeleteIfEmpty:=0 as numeric

    local nft_fRecNo as numeric
    local nft_fHandle as numeric

    local nDBS_ALEN:=(DBS_ALEN+1) as numeric

    local nMLCountSize:=150 as numeric

    local nAliasdbCount:=0 as numeric

    local nTmpAliasOrder as numeric
    local nTmpAliasNextRecNo:=(-1) as numeric

    local oFT as object
    local oTFIni as object
    local oProgress:=txtProgress():New() as object

    local oSourceJSONLine:=JSONObject():New()

    local oTimeRemaining as object

    local oFWTemporaryTable as object

    local oHMMemoVirutal as object

    local oHMIncProcStep as object

    local oHMTargetStruct as object
    local oHMTargetFieldsPos as object
    local oHMTargetFieldsDef as object
    local oHMTargetReplicateFields as object

    local oHMSourceFieldsDef as object

    begin sequence

        dfv():Default(@lPreLoadTable,.F.)

        nIndexKey:=retOrder(cTargetAlias,cIndexKey,(!lPreLoadTable))

        lImportData:=((lPreLoadTable).or.(nIndexKey!=0))
        if (!lImportData)
            ApMsgAlert("Unlocalized "+cTargetAlias+" table search index ("+cIndexKey+")")
            break
        endif

        oTFIni:=GetValue("readIniFile")

        cFieldFilial:=PrefixoCpo(cTargetAlias)
        cFieldFilial+="_FILIAL"

        lChkFilial:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"ChkFilial","1"))=="1")
        cAliasxFilial:=xFilial(cTargetAlias)

        lAskUpdate:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"AskUpdate","1"))=="1")
        if ((lAskUpdate).and.(cTargetAlias==cTableImport))
            if (lChkFilial)
                nFieldFilial:=(cTargetAlias)->(FieldPos(cFieldFilial))
                if (left(cIndexKey,Len(cFieldFilial))==cFieldFilial)
                    (cTargetAlias)->(dbSetOrder(nIndexKey))
                    (cTargetAlias)->(dbSeek(cAliasxFilial,.T.))
                else
                    (cTargetAlias)->(dbGoTop())
                endif
            endif
            FWMsgRun(nil,{||nAliasdbCount:=datasul2totvs.GetRecCount(RetSQLName(cTargetAlias),"D_E_L_E_T_=' '")},"Wait...","Verifying records in the DBMS")
            if (nAliasdbCount>0)
                lImportData:=ApMsgNoYes("There is already data in this table. Do you want to update them?","Info")
                if (!lImportData)
                    break
                endif
            endif
        endif

        cSourceTable:=allTrim(oTFIni:GetPropertyValue("TablesImport",cTableImport,""))
        lImportData:=(!empty(cSourceTable))
        if (!lImportData)
            ApMsgAlert("There is no setting for the "+cSourceTable+" table","Attention")
            break
        endif

        cDataPath:=GetDataPath()
        lImportData:=(!empty(cDataPath))
        if (!lImportData)
            ApMsgAlert("Invalida Data Path ("+cDataPath+")","Attention")
            break
        endif

        cDataPathSplit:=GetDataPathSplit()
        if (!empty(cDataPathSplit))
            cDataPathSplit+=(cSourceTable+"\")
            aDataPathSplit:=Directory(cDataPathSplit+cSourceTable+"*.csv")
            if (!Empty(aDataPathSplit)).and.ApMsgYesNo(cTools():Accentuation("Deseja Selecionar o Arquivo para importa#1#2o?","ccedil","atilde"),cTools():Accentuation("Aten#1#2o!","ccedil","atilde"))
                cGetFileMask:=(cSourceTable+" | "+cSourceTable+"*.csv")
                cGetFileTitle:=cSourceTable
                nGetFileOptions:=(GETF_LOCALHARD+GETF_NETWORKDRIVE)
                cDataPathSplit:=strTran("SERVIDOR"+cDataPathSplit,"\ini\..","")
                cSourceFile:=cGetFile(cGetFileMask,cGetFileTitle,1,cDataPathSplit,.F.,nGetFileOptions,/*[lArvore]*/,/*[lKeepCase]*/)
            endif
            FWFreeArray(@aDataPathSplit)
        endif

        if (empty(cSourceFile))
            cSourceFile:=(cDataPath+cSourceTable+".csv")
            lImportData:=file(cSourceFile)
            if (!lImportData)
                ApMsgAlert("File ("+cSourceFile+") not found","Attention")
                break
            endif
        endif

        aFieldsDef:=aClone(GetValue(cSourceTable,aFieldsDef))
        lImportData:=(!empty(aFieldsDef))
        if (!lImportData)
            ApMsgAlert("Field definitions for the "+cSourceTable+" table not found","Attention")
            break
        endif

        lTypeReplicate:=GetValue(cSourceTable+"_TypeReplicate",lTypeReplicate)
        if (lTypeReplicate)
            lTypeReplicateRow:=(Lower(allTrim(oTFIni:GetPropertyValue(cSourceTable,"TypeReplicate","")))=="row")
        endif

        oHMSourceFieldsDef:=THashMap():New()
        nFields:=Len(aFieldsDef)
        for nField:=1 to nFields
            oHMSourceFieldsDef:Set(aFieldsDef[nField][DTS_DBS_NAME],aFieldsDef[nField][DTS_DBS_TYPE])
            oHMSourceFieldsDef:Set(aFieldsDef[nField][DTS_DBS_NAME]+"_AT",nField)
        next nField

        aTargetFieldsDef:=aClone(oTFIni:GetAllProperties(cSourceTable))
        lImportData:=(!empty(aFieldsDef))
        if (!lImportData)
            ApMsgAlert("Field definitions for the "+cTableImport+" table not found","Attention")
            break
        endif

        lAddFieldTmp:=(val(allTrim(oTFIni:GetPropertyValue(cTableImport,"addTmpField","0")))==1)
        if (lAddFieldTmp)
            cTmpFields:=allTrim(oTFIni:GetPropertyValue(cTableImport+"_addTmpField","TmpFields",""))
            lAddFieldTmp:=(!Empty(cTmpFields))
            if (lAddFieldTmp)
                aSourceTmpFields:=cTools():StrTokArray(cTmpFields,",")
                nFields:=Len(aSourceTmpFields)
                if (nFields>0)
                    aSourceTmpFldStruct:=array(0)
                    for nField:=1 to nFields
                        cField:=aSourceTmpFields[nField]
                        aAdd(aSourceTmpFldStruct,array(DBS_ALEN))
                        aSourceTmpFldStruct[nField][DBS_NAME]:=Upper(allTrim(oTFIni:GetPropertyValue(cField,"DBS_NAME","")))
                        aSourceTmpFldStruct[nField][DBS_TYPE]:=Upper(allTrim(oTFIni:GetPropertyValue(cField,"DBS_TYPE","")))
                        aSourceTmpFldStruct[nField][DBS_LEN]:=val(allTrim(oTFIni:GetPropertyValue(cField,"DBS_LEN","1")))
                        aSourceTmpFldStruct[nField][DBS_DEC]:=val(allTrim(oTFIni:GetPropertyValue(cField,"DBS_DEC","0")))
                    next nField
                endif
                FWFreeArray(@aSourceTmpFields)
            endif
        endif

        lMemoVirutal:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"MemoVirtual","0"))=="1")
        if (lMemoVirutal)
            oHMMemoVirutal:=THashMap():New()
        endif

        if (lMemoVirutal)
            nFields:=Len(aTargetStruct)
            for nField:=1 to nFields
                cField:=aTargetStruct[nField][DBS_NAME]
                if (allTrim(oTFIni:GetPropertyValue(cField,"MemoVirtual","0"))=="1")
                    bUpdateMemoVirtual:=&(allTrim(oTFIni:GetPropertyValue(cField,"bUpdateMemoVirtual","{||}")))
                    oHMMemoVirutal:Set(cField,bUpdateMemoVirtual)
                endif
            next nField
        endif

        if (lAddFieldTmp)
            aEval(aSourceTmpFldStruct,{|e|aAdd(aTargetStruct,aClone(e))})
        endif

        oHMTargetStruct:=aUtils():dbStructHM(@aTargetStruct)

        nFields:=Len(aTargetFieldsDef)

        cTargetIgnoreFields:=allTrim(oTFIni:GetPropertyValue(cTableImport,"bTargetIgnoreFields",""))
        if (!empty(cTargetIgnoreFields))
            bTargetIgnoreFields:=&(cTargetIgnoreFields)
            aTargetFieldsDefTmp:=array(0)
            for nField:=1 to nFields
                cField:=aTargetFieldsDef[nField][1]
                if (eval(bTargetIgnoreFields,cField))
                    loop
                endif
                aAdd(aTargetFieldsDefTmp,aClone(aTargetFieldsDef[nField]))
            next nField
            aSize(aTargetFieldsDef,0)
            aEval(aTargetFieldsDefTmp,{|e|aAdd(aTargetFieldsDef,aClone(e))})
            FWFreeArray(@aTargetFieldsDefTmp)
            nFields:=Len(aTargetFieldsDef)
        endif

        if (lTypeReplicate)
            cNoReplicateValues:=allTrim(oTFIni:GetPropertyValue(cTableImport,"NoReplicateValues",""))
            aNoReplicateValues:=cTools():StrTokArray(cNoReplicateValues,",")
            aTargetReplicateFields:=array(0)
            oHMTargetReplicateFields:=THashMap():New()
        endif

        oHMTargetFieldsPos:=THashMap():New()
        oHMTargetFieldsDef:=THashMap():New()

        for nField:=1 to nFields
            cField:=aTargetFieldsDef[nField][1]
            if (oHMTargetStruct:Get(cField,@aField))
                nTargetFieldPos:=aField[1][nDBS_ALEN]
            else
                nTargetFieldPos:=0
            endif
            oHMTargetFieldsPos:Set(cField,nTargetFieldPos)
            oHMTargetFieldsDef:Set(cField,nField)
            aAdd(aTargetFieldsDef[nField],nTargetFieldPos)
            if (lTypeReplicate).and.(nTargetFieldPos>0)
                aAdd(aTargetReplicateFields,cField)
                oHMTargetReplicateFields:Set(cField,Len(aTargetReplicateFields))
            endif
        next nField

        oHMTargetStruct:Clean()
        FreeObj(@oHMTargetStruct)

        lEnableFilterBlock:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"EnableFilterBlock","0"))=="1")
        if (lEnableFilterBlock)
            bEnableFilterBlock:=GetValue(cTableImport+"EnableFilterBlock",{||.T.})
            cFieldsFilterBlock:=allTrim(oTFIni:GetPropertyValue(cTableImport,"FieldsFilterBlock",""))
            bEnableFilterBlockMem:=GetValue(cTableImport+"EnableFilterBlockMem",{||.T.})
        endif

        lChkEncode:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"ChkEncode","0"))=="1")
        lTablesEncodeUTF8:=(allTrim(oTFIni:GetPropertyValue("General","TablesEncodeUTF8","0"))=="1")

        oFT:=ftDb():New("SQLITE_TMP")
        bSourceGetLine:={|cLine,nLine,nFileSize,nBufferSize,nBytesRead|GetLineFromSource(cLine,nLine,nFileSize,nBufferSize,nBytesRead,cSourceFile,lChkEncode,lTablesEncodeUTF8,oProgress,@lSetRegua,@nSetRegua,cCRLF)}
        oFT:ft_fSetGetLine(bSourceGetLine)
        bSourceAppendLine:={|nRecNoAT,uLine|oSourceJSONLine["Line"]:=uLine,oSourceJSONLine:ToJSON()}
        oFT:ft_fSetAppend(bSourceAppendLine)
        if (valtype(GetValue(cTableImport+"SourceSetFilter",nil))=="B")
            bSourceSetFilter:=GetValue(cTableImport+"SourceSetFilter")
            oFT:ft_fSetFilter(bSourceSetFilter)
        endif

        MsProcess():MsAguarde({||nft_fHandle:=oFT:ft_fUse(cSourceFile)},"Wait! Loading Data File.","["+cSourceFile+"]",nil,.T.)

        lImportData:=(nft_fHandle>=0)
        if (!lImportData)
            ApMsgAlert("Could not open the file: "+cSourceFile,"Attention")
            break
        endif

        lImportData:=(Len(aTargetStruct)>=0)
        if (!lImportData)
            ApMsgAlert("Could not get structure for table:  "+cTableImport,"Attention")
            break
        endif

        lTCSQLUpdateTable:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"TCSQLUpdateTable","0"))=="1")

        if (lTCSQLUpdateTable)
            oFWTemporaryTable:=FWTemporaryTable():New(@cSourceAlias,@aTargetStruct)
            oFWTemporaryTable:AddIndex("01",aAddIndex)
            oFWTemporaryTable:Create()
            cFWTemporaryTableRealName:=oFWTemporaryTable:getRealName()
            SetValue("import"+cTableImport+"FWTemporaryTable",oFWTemporaryTable)
        else
            cFWTemporaryTableRealName:=criaTrab(nil,.F.)
            dbCreate(cFWTemporaryTableRealName,aTargetStruct,"SQLITE_MEM")
            dbUseArea(.T.,"SQLITE_MEM",cFWTemporaryTableRealName,cSourceAlias,.F.,.F.)
            dbSelectArea(cSourceAlias)
            INDEX ON &(cIndexKey) TAG &(cFWTemporaryTableRealName+"1") TO &(cFWTemporaryTableRealName+"1")
        endif

        (cSourceAlias)->(dbSetOrder(1))

        SetValue("import"+cTableImport+"Alias",cSourceAlias)
        SetValue("import"+cTableImport+"Table",cFWTemporaryTableRealName)

        FWFreeArray(@aField)
        FWFreeArray(@aTargetStruct)

        bAddTLogReport:=&(allTrim(oTFIni:GetPropertyValue(cTableImport,"bAddTLogReport","{|cAlias,cTableImport,oTLogReport|.F.}")))
        bDeleteIfEmpty:=&(allTrim(oTFIni:GetPropertyValue(cTableImport,"bDeleteIfEmpty","{|cAlias|.F.}")))

        lSeekTable:=(!empty(cSeekTable:=allTrim(oTFIni:GetPropertyValue(cTableImport,"seekTable",""))))
        if (lSeekTable)
            lSeekTable:=chkFile(cSeekTable)
            if (lSeekTable)
                cSeekIndexKey:=allTrim(oTFIni:GetPropertyValue(cTableImport,"seekIndexKey",""))
                cSeekTableIndex:=allTrim(oTFIni:GetPropertyValue(cTableImport,"seekTableIndex",""))
                nSeekTableIndex:=retOrder(cSeekTable,cSeekTableIndex,.T.)
                lSeekTable:=(nSeekTableIndex>0)
                if (lSeekTable)
                    (cSeekTable)->(dbSetOrder(nSeekTableIndex))
                    cUpdateTableFields:=allTrim(oTFIni:GetPropertyValue(cTableImport,"updateTableFields",""))
                    aUpdateTableFields:=cTools():StrTokArray(cUpdateTableFields,",")
                    cUpdateTableSource:=allTrim(oTFIni:GetPropertyValue(cTableImport,"updateTableSource",""))
                    aUpdateTableSource:=cTools():StrTokArray(cUpdateTableSource,",")
                    nUpdateTableSource:=len(aUpdateTableFields)
                    lUpdateTableFields:=((nUpdateTableSource>0).and.(nUpdateTableSource==len(aUpdateTableSource)))
                endif
            endif
        endif

        nIncProcStep:=Int(val(allTrim(oTFIni:GetPropertyValue(cTableImport,"IncProcStep","0"))))
        if (empty(nIncProcStep))
            nIncProcStep:=Int(val(allTrim(oTFIni:GetPropertyValue("General","IncProcStep","1"))))
        endif
        nIncProcStep:=Min(Max(nIncProcStep,1),1000)

        begin sequence

            nStartLine:=GetValue(cTableImport+"StartLine",1)
            if (nStartLine==1)
                nStartLine:=val(allTrim(oTFIni:GetPropertyValue(cTableImport,"StartLine","1")))
            endif

            nRecCount:=oFT:ft_fLastRec()

            nEndLine:=GetValue(cTableImport+"EndLine",nRecCount)
            if (nEndLine>=nRecCount)
                nEndLine:=val(allTrim(oTFIni:GetPropertyValue(cTableImport,"EndLine",cTools():NToS(nRecCount))))
            endif
            nRecCount:=Min(nRecCount,nEndLine)

            if (nStartLine>1)
                nRecCount:=((nRecCount-nStartLine)+1)
                oFT:ft_fGoTo(nStartLine)
            else
                oFT:ft_fGoTop()
            endif

            nRecCountProc:=nRecCount

            if ((lPercentage).and.(nRecCount>=1000))
                nIncProcStep=(1/nRecCount*100)
                nRecCount:=200
                aIncProcStep:=array(nRecCount,2)
                aEval(aIncProcStep,{|x,y|aIncProcStep[y][2]:=((y*5)/100),aIncProcStep[y][1]:=Round((nRecCountProc*aIncProcStep[y][2]),0)})
                oHMIncProcStep:=aToHM(aIncProcStep)
                FWFreeArray(@aIncProcStep)
            else
                lPercentage:=.F.
                if (nRecCount<=nIncProcStep)
                    nIncProcStep:=1
                endif
            endif

            cRecCount:=cTools():NToS(nRecCountProc)

            oMsNewProcess:SetRegua1(if(lPercentage,nRecCount,Round(nRecCount/nIncProcStep,0)))

            oTimeRemaining:=timeRemaining():New(nRecCountProc)

            if (lTypeReplicate)
                for nField:=1 to nFields
                    nReplicates:=GetValue(aTargetFieldsDef[nField][2]+"_TypeReplicate",0)
                    if (nReplicates>0)
                        exit
                    endif
                next nField
            endif

            bSourceGetLine:={|nRecNoAT,uLine|oSourceJSONLine:FromJSON(uLine),oSourceJSONLine["Line"]}

            while (!oFT:ft_fEof())

                nft_fRecNo:=oFT:ft_fRecNo()
                aLine:=oFT:ft_fReadLN(bSourceGetLine)

                begin sequence

                    if (empty(aLine))
                        break
                    endif

                    lAppend:=.T.
                    lHasError:=.F.
                    lSeekTableFound:=.F.

                    if ((lChkFilial).or.(lEnableFilterBlock).or.(lAddFieldTmp))

                        for nField:=1 to nFields
                            cField:=aTargetFieldsDef[nField][1]
                            if (;
                                    (;
                                        (lChkFilial).and.(cField==cFieldFilial);
                                    ).or.;
                                    (;
                                        (lEnableFilterBlock).and.(cField$cFieldsFilterBlock);
                                    ).or.;
                                    (;
                                        (lAddFieldTmp).and.(aScan(aAddIndex,{|e|(e==cField)})>0);
                                    );
                                )
                                lHasError:=.F.
                                xValue:=(cSourceAlias)->(;
                                    getTargetFieldValue(;
                                        @lHasError,;
                                        @oTFIni,;
                                        @aLine,;
                                        @cField,;
                                        aTargetFieldsDef[nField],;
                                        @aFieldsDef,;
                                        @oHMSourceFieldsDef;
                                    );
                                )
                                if (lHasError)
                                    cError:=EvalBlockGetValue("ErrorDescription","")
                                    cError+=EvalBlockGetValue("ErrorStack","")
                                    DelSection("EvalBlock")
                                    if (!empty(cError))
                                        cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                        cError:=""
                                        cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                        oTLogReport:AddGroup(cTLogGroup)
                                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                        cTLogDetail:=""
                                        cLine:=""
                                        aEval(aLine,{|e|cLine+=e+";"})
                                        oTLogReport:AddDetail(cTLogGroup,cLine,nMLCountSize)
                                        cLine:=""
                                        lEnd:=oMsNewProcess:lEnd:=.T.
                                        lAppend:=.F.
                                        break
                                    endif
                                endif
                                if (empty(xValue))
                                    if (lHasError)
                                        cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                        oTLogReport:AddGroup(cTLogGroup)
                                        cTLogDetail:="Estrutura da Linha diferente da estrutura de Dados"
                                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail)
                                        cLine:=""
                                        aEval(aLine,{|e|cLine+=e+";"})
                                        oTLogReport:AddDetail(cTLogGroup,cLine,nMLCountSize)
                                        cLine:=""
                                    endif
                                    lAppend:=((!lHasError).and.(lTypeReplicate).and.((nReplicates>0).and.(lTypeReplicateRow)))
                                    if (!lAppend)
                                        exit
                                    endif
                                endif
                            endif
                            if ((lChkFilial).and.(cField==cFieldFilial))
                                SetFilAnt(xValue)
                            endif
                            if ((lEnableFilterBlock).and.(cField$cFieldsFilterBlock))
                                lHasError:=(!EvalBlock():EvalBlock({||lAppend:=(Eval(bEnableFilterBlockMem,xValue,cField))},nil,.F.,nil,nil))
                                if (lHasError)
                                    cError:=EvalBlockGetValue("ErrorDescription","")
                                    cError+=EvalBlockGetValue("ErrorStack","")
                                    DelSection("EvalBlock")
                                    if (!empty(cError))
                                        cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                        cError:=""
                                        cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                        oTLogReport:AddGroup(cTLogGroup)
                                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                        cTLogDetail:=""
                                        cLine:=""
                                        aEval(aLine,{|e|cLine+=e+";"})
                                        oTLogReport:AddDetail(cTLogGroup,cLine,nMLCountSize)
                                        cLine:=""
                                        cError:=""
                                    endif
                                endif
                                if (!lAppend)
                                    lAppend:=((!lHasError).and.(lTypeReplicate).and.((nReplicates>0).and.(lTypeReplicateRow)))
                                    if (!lAppend)
                                        exit
                                    endif
                                endif
                            endif
                        next nField

                    endif

                    if (lEnd)
                        break
                    endif

                    if (!lAppend)
                        lAppend:=((!lHasError).and.(lTypeReplicate).and.((nReplicates>0).and.(lTypeReplicateRow)))
                        if (!lAppend)
                            break
                        endif
                    endif

                    (cSourceAlias)->(dbAppend(.F.))

                    ldbCommit:=(++nCommitBuffer>=1024)

                    if (lSeekTable)
                        cAllSeekIndexKey:=cSeekIndexKey
                    endif

                    for nField:=1 to nFields

                        cField:=aTargetFieldsDef[nField][1]

                        if ((!lChkFilial).and.(cField==cFieldFilial))

                            xValue:=cAliasxFilial

                        else

                            if ((nReplicates>0).and.(!lTypeReplicateRow).and.(GetValue(aTargetFieldsDef[nField][2]+"_TypeReplicate",0)>0))

                                nReplicate:=0

                                while (((++nReplicate)<=nReplicates))

                                    lHasError:=.F.

                                    if (nReplicate==1)

                                        xValue:=(cSourceAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,aTargetFieldsDef[nField],@aFieldsDef,@oHMSourceFieldsDef))

                                    else

                                        aTargetFieldsDefReplicate:=aClone(aTargetFieldsDef[nField])
                                        aTargetFieldsDefReplicate[2]+=cTools():NToS(nReplicate)

                                        xValue:=(cSourceAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,@aTargetFieldsDefReplicate,@aFieldsDef,@oHMSourceFieldsDef))

                                        FWFreeArray(@aTargetFieldsDefReplicate)

                                    endif

                                    if (lHasError)

                                        cError:=EvalBlockGetValue("ErrorDescription","")
                                        cError+=EvalBlockGetValue("ErrorStack","")
                                        DelSection("EvalBlock")

                                        if (!empty(cError))
                                            cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                            cError:=""
                                            cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                            oTLogReport:AddGroup(cTLogGroup)
                                            oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                            cTLogDetail:=""
                                            cLine:=""
                                            aEval(aLine,{|e|cLine+=e+";"})
                                            oTLogReport:AddDetail(cTLogGroup,cLine,nMLCountSize)
                                            cLine:=""
                                            lEnd:=oMsNewProcess:lEnd:=.T.
                                            lAppend:=.F.
                                            break
                                        endif

                                    endif

                                    if ((!oHMTargetFieldsPos:Get(cField,@nTargetFieldPos)).or.(nTargetFieldPos==0))
                                        loop
                                    endif

                                    (cSourceAlias)->(FieldPut(nTargetFieldPos,xValue))

                                end while

                                loop

                            else

                                lHasError:=.F.

                                xValue:=(cSourceAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,aTargetFieldsDef[nField],@aFieldsDef,@oHMSourceFieldsDef))

                            endif

                            if (lHasError)

                                cError:=EvalBlockGetValue("ErrorDescription","")
                                cError+=EvalBlockGetValue("ErrorStack","")
                                DelSection("EvalBlock")

                                if (!empty(cError))
                                    cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                    cError:=""
                                    cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                    oTLogReport:AddGroup(cTLogGroup)
                                    oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                    cLine:=""
                                    aEval(aLine,{|e|cLine+=e+";"})
                                    oTLogReport:AddDetail(cTLogGroup,cLine,nMLCountSize)
                                    cLine:=""
                                    cTLogDetail:=""
                                    lEnd:=oMsNewProcess:lEnd:=.T.
                                    break
                                endif

                            endif

                        endif

                        if (empty(xValue))
                            if (lHasError)
                                cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                oTLogReport:AddGroup(cTLogGroup)
                                cTLogDetail:="Estrutura da Linha diferente da estrutura de Dados"
                                oTLogReport:AddDetail(cTLogGroup,cTLogDetail)
                                cLine:=""
                                aEval(aLine,{|e|cLine+=e+";"})
                                oTLogReport:AddDetail(cTLogGroup,cLine,nMLCountSize)
                                cLine:=""
                                lHasError:=(!EvalBlock():EvalBlock({||lDeleteIfEmpty:=((cSourceAlias)->(Eval(bDeleteIfEmpty,cSourceAlias)))},nil,.F.,nil,nil))
                                if (lDeleteIfEmpty)
                                    (cSourceAlias)->(dbDelete())
                                    nDeleteIfEmpty++
                                    break
                                endif
                                exit
                            endif
                            if (!lUpdateEmptyValue)
                                loop
                            endif
                        endif

                        if ((!oHMTargetFieldsPos:Get(cField,@nTargetFieldPos)).or.(nTargetFieldPos==0))
                            loop
                        endif

                        (cSourceAlias)->(FieldPut(nTargetFieldPos,xValue))

                        if ((lSeekTable).and.(!empty(cAllSeekIndexKey)))
                            if (cField$cAllSeekIndexKey)
                                cAllSeekIndexKey:=cTools():StrReplace(cAllSeekIndexKey,{cField,""})
                            endif
                            if (empty(cTools():StrReplace(cAllSeekIndexKey,{"+",""})))
                                cAllSeekIndexKey:=""
                                if (!lSeekTableFound)
                                    lSeekTableFound:=(cSeekTable)->(MsSeek((cSourceAlias)->(&(cSeekIndexKey)),.F.))
                                endif
                            endif
                        endif

                    next nField

                    lHasError:=(!EvalBlock():EvalBlock({||(cSourceAlias)->(Eval(bAddTLogReport,cSourceAlias,cTableImport,oTLogReport))},nil,.F.,nil,nil))

                    lHasError:=(!EvalBlock():EvalBlock({||lDeleteIfEmpty:=((cSourceAlias)->(Eval(bDeleteIfEmpty,cSourceAlias)))},nil,.F.,nil,nil))
                    if (lDeleteIfEmpty)
                        (cSourceAlias)->(dbDelete())
                        nDeleteIfEmpty++
                    endif

                    if (!lDeleteIfEmpty)

                        if (lEnableFilterBlock)
                            lHasError:=(!EvalBlock():EvalBlock({||lFilterBlock:=(cSourceAlias)->(!Eval(bEnableFilterBlock,cSourceAlias))},nil,.F.,nil,nil))
                            if ((!lHasError).and.(lFilterBlock))
                                (cSourceAlias)->(dbDelete())
                                nDeleteIfEmpty++
                            endif
                        endif

                        if (lSeekTable)

                            if (!lSeekTableFound)
                                lSeekTableFound:=(cSeekTable)->(MsSeek((cSourceAlias)->(&(cSeekIndexKey)),.F.))
                            endif

                            if (lSeekTableFound)

                                if ((lUpdateTableFields).and.(lLock:=MySoftLock(cSeekTable)))

                                    lLock:=(cSeekTable)->(MyRecLock(cSeekTable,.F.))

                                    if (lLock)

                                        for nField:=1 to nUpdateTableSource

                                            cField:=aUpdateTableSource[nField]

                                            if ((oHMTargetFieldsDef:Get(cField,@nTargetFieldAT)).and.(nTargetFieldAT>0))

                                                lHasError:=.F.
                                                xValue:=(cSourceAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,aTargetFieldsDef[nTargetFieldAT],@aFieldsDef,@oHMSourceFieldsDef,@cType))

                                                if (lHasError)

                                                    cError:=EvalBlockGetValue("ErrorDescription","")
                                                    cError+=EvalBlockGetValue("ErrorStack","")
                                                    DelSection("EvalBlock")

                                                    if (!empty(cError))
                                                        cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                                        cError:=""
                                                        cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                                        oTLogReport:AddGroup(cTLogGroup)
                                                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                                        cTLogDetail:=""
                                                        lEnd:=oMsNewProcess:lEnd:=.T.
                                                        break
                                                    endif

                                                endif

                                                cField:=aUpdateTableFields[nField]
                                                xValue:=NormalizeData(@lHasError,xValue,cType,cField,.T.,@st_oHMbTransform,@oTFIni)

                                                if (lHasError)

                                                    cError:=EvalBlockGetValue("ErrorDescription","")
                                                    cError+=EvalBlockGetValue("ErrorStack","")
                                                    DelSection("EvalBlock")

                                                    if (!empty(cError))
                                                        cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                                        cError:=""
                                                        cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                                        oTLogReport:AddGroup(cTLogGroup)
                                                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                                        cTLogDetail:=""
                                                        lEnd:=oMsNewProcess:lEnd:=.T.
                                                        (cSeekTable)->(MsUnLock())
                                                        break
                                                    endif

                                                endif

                                            endif

                                            (cSeekTable)->(FieldPut(FieldPos(cField),xValue))

                                        next nField

                                        (cSeekTable)->(MsUnLock())

                                    endif

                                endif

                            endif

                        endif

                    endif

                    if ((nReplicates>0).and.(lTypeReplicateRow))

                        aReplicateValues:=(cSourceAlias)->(aUtils():RegToArray(cSourceAlias,recNo(),aTargetReplicateFields,.F.,.F.,@aTargetReplicateFieldsPos))
                        nReplicate:=1

                        while (((++nReplicate)<=nReplicates))

                            lAppend:=.T.

                            (cSourceAlias)->(dbAppend(.F.))
                            ldbCommit:=(++nCommitBuffer>=1024)

                            for nField:=1 to nFields

                                cField:=aTargetFieldsDef[nField][1]

                                if (GetValue(aTargetFieldsDef[nField][2]+"_TypeReplicate",0)>0)

                                    aTargetFieldsDefReplicate:=aClone(aTargetFieldsDef[nField])
                                    aTargetFieldsDefReplicate[2]+=cTools():NToS(nReplicate)
                                    xValue:=(cSourceAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,@aTargetFieldsDefReplicate,@aFieldsDef,@oHMSourceFieldsDef))

                                    FWFreeArray(@aTargetFieldsDefReplicate)

                                else

                                    if (!oHMTargetReplicateFields:Get(cField,@nReplicateValuesAT))
                                        loop
                                    endif

                                    if (aScan(aNoReplicateValues,{|x|(x==cField)})==0)
                                        xValue:=aReplicateValues[nReplicateValuesAT]
                                    else
                                        xValue:=(cSourceAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,aTargetFieldsDef[nField],@aFieldsDef,@oHMSourceFieldsDef,@cType))
                                    endif

                                endif

                                if ((lEnableFilterBlock).and.(cField$cFieldsFilterBlock))
                                    lHasError:=(!EvalBlock():EvalBlock({||lAppend:=(Eval(bEnableFilterBlockMem,xValue,cField))},nil,.F.,nil,nil))
                                    if ((!lHasError).and.(!lAppend))
                                        (cSourceAlias)->(dbDelete())
                                        nDeleteIfEmpty++
                                        exit
                                    endif
                                endif

                                if ((!oHMTargetFieldsPos:Get(cField,@nTargetFieldPos)).or.(nTargetFieldPos==0))
                                    loop
                                endif

                                (cSourceAlias)->(FieldPut(nTargetFieldPos,xValue))

                            next nField

                            lHasError:=(!EvalBlock():EvalBlock({||(cSourceAlias)->(Eval(bAddTLogReport,cSourceAlias,cTableImport,oTLogReport))},nil,.F.,nil,nil))

                            if (lAppend)
                                lHasError:=(!EvalBlock():EvalBlock({||lDeleteIfEmpty:=((cSourceAlias)->(Eval(bDeleteIfEmpty,cSourceAlias)))},nil,.F.,nil,nil))
                                if (lDeleteIfEmpty)
                                    (cSourceAlias)->(dbDelete())
                                    nDeleteIfEmpty++
                                endif
                            endif

                        end while

                        FwFreeArray(@aReplicateValues)

                    endif

                end sequence

                cLine:=""
                FWFreeArray(@aLine)

                nRecProc++
                if (lPercentage)
                    nRecProcPerc:=(nRecProc*nIncProcStep)
                else
                    nRecProcPerc:=nRecProc
                endif

                oTimeRemaining:nProgress:=nRecProc

                if ((if(lPercentage,(oHMIncProcStep:Get(nRecProc)),(Mod(nRecProcPerc,nIncProcStep)==0))).or.(nRecProcPerc>=nRecCount))
                    oTimeRemaining:Calcule(.F.)
                    cTimeRemaining:=" :: End of processing in ["+oTimeRemaining:GetcTRemaining()+"]["+DtoC(oTimeRemaining:GetdEndTime())+"]"
                    cTimeRemaining+="["+oTimeRemaining:GetcEndTime()+"]"
                    cTimeRemaining+="[+/-]"
                    cTimeRemaining+="["+oTimeRemaining:GetcAverageTime()+"]"
                    cIncProc:="["+oProgress:Eval()+"] "
                    cIncProc+="Processing Record ["
                    cIncProc+=cTools():NToS(nRecProc)
                    cIncProc+="/"
                    cIncProc+=cRecCount
                    cIncProc+="] :: "
                    cIncProc+="Table ["+cFWTemporaryTableRealName+"]"
                    cIncProc+=cTimeRemaining
                    cIncProc+=" :: ["+cTools():NToS(Round(if((nRecProcPerc>=nRecCount),100,((nRecProc/nRecCountProc)*100)),2))+"%]"
                    oMsNewProcess:IncRegua1(cIncProc)
                endif

                lEnd:=oMsNewProcess:lEnd

                if (lEnd)
                    cTLogGroup:="Process canceled by user:"
                    oTLogReport:AddGroup(cTLogGroup)
                    cTLogDetail:="Process canceled by user ["+DtoC(Date())+"]["+Time()+"]"
                    oTLogReport:AddDetail(cTLogGroup,cTLogDetail)
                    exit
                endif

                if (ldbCommit)
                    nCommitBuffer:=0
                    (cSourceAlias)->(dbCommitAll())
                endif

                if (ldbCommit)
                    ldbCommit:=.F.
                endif

                if (nRecProcPerc>=nRecCount)
                    exit
                endif

                oFT:ft_fSkip()

            end while

            if (lPercentage)
                oHMIncProcStep:Clean()
                FreeObj(@oHMIncProcStep)
            endif

            cLine:=""
            FWFreeArray(@aLine)

            if (nCommitBuffer>0)
                (cSourceAlias)->(dbCommitAll())
            endif

            oFT:ft_fUse()
            oFT:FreeObj()
            FreeObj(@oFT)

            cTLogGroup:="["+cAlias+"/"+cTableImport+"]"

            cTLogDetail:="Data: ["+DToC(oTimeRemaining:GetdStartTime())+"]"
            cTLogDetail+=" "
            cTLogDetail+="Hora: ["+oTimeRemaining:GetcStartTime()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Inicio da Leitura/Processamento de Dados (Datasul)."
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:="Data: ["+DToC(oTimeRemaining:GetdEndTime())+"]"
            cTLogDetail+=" "
            cTLogDetail+="Hora: ["+oTimeRemaining:GetcEndTime()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Termino da Leitura/Processamento de Dados (Datasul)."
            cTLogDetail+=" : "
            cTLogDetail+="Decorridos: ["+oTimeRemaining:GetcTimeDiff()+"]"
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:=oTLogReport:ThinLine()
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:="["+oTimeRemaining:GetcTimeDiff()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Tempo de Processamento Leitura/Processamento de Dados (Datasul).
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:="["+oTimeRemaining:GetcAverageTime()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Tempo Medio de Processamento Leitura/Processamento de Dados (Datasul).
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:=oTLogReport:ThinLine()
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            if ((lEnd).or.(lPreLoadTable))
                break
            endif

            if (nDeleteIfEmpty>0)
                if (lTCSQLUpdateTable)
                    FWMsgRun(nil,{||nDeleteIfEmpty:=dbEval():SQLDelete(cFWTemporaryTableRealName,"D_E_L_E_T_='*'"),TCRefresh(cFWTemporaryTableRealName)},"Wait...","Removing deleted Records...")
                else
                    FWMsgRun(nil,{||__dbPack()},"Wait...","Removing deleted Records...")
                endif
            endif

            cTargetAliasRealName:=RetSQLName(cTargetAlias)
            if (lTCSQLUpdateTable)
                MsProcess():MsAguarde(;
                    {||;
                        datasul2totvs.TCSQLUpdateTable(;
                            cSourceAlias,;
                            cFWTemporaryTableRealName,;
                            cTargetAlias,;
                            cTargetAliasRealName,;
                            aTargetFieldsDef,;
                            aAddIndex,;
                            aSourceTmpFldStruct,;
                            oMsNewProcess,;
                            oTLogReport,;
                            oProgress;
                        );
                    },;
                    "Wait...",;
                    "Updating data from table "+cTargetAliasRealName,;
                    nil,;
                    .T.;
                )
            endif

            if (lTCSQLUpdateTable)
                FWMsgRun(nil,{||nAliasdbCount:=datasul2totvs.GetRecCount(cFWTemporaryTableRealName)},"Wait...","Verifying record data for import")
                nRecCount:=Min(nAliasdbCount,(cSourceAlias)->(recCount()))
            else
                nRecCount:=(cSourceAlias)->(recCount())
            endif

            nRecCountProc:=nRecCount

            if ((lPercentage).and.(nRecCount>=1000))
                nIncProcStep=(1/nRecCount*100)
                nRecCount:=200
                aIncProcStep:=array(nRecCount,2)
                aEval(aIncProcStep,{|x,y|aIncProcStep[y][2]:=((y*5)/100),aIncProcStep[y][1]:=Round((nRecCountProc*aIncProcStep[y][2]),0)})
                oHMIncProcStep:=aToHM(aIncProcStep)
                FWFreeArray(@aIncProcStep)
            else
                lPercentage:=.F.
                if (nRecCount<=nIncProcStep)
                    nIncProcStep:=1
                endif
            endif

            cRecCount:=cTools():NToS(nRecCountProc)

            oMsNewProcess:SetRegua2(if(lPercentage,nRecCount,Round(nRecCount/nIncProcStep,0)))

            oTimeRemaining:SetRemaining(nRecCountProc)
            if (nRecCountProc==0)
                oTimeRemaining:Calcule(.F.)
            endif

            (cTargetAlias)->(dbSetOrder(nIndexKey))

            nRecProc:=0

            lCustomUpdate:=((valType(bCustomUpdate)=="B").or.(allTrim(oTFIni:GetPropertyValue(cTableImport,"CustomUpdate","0"))=="1"))
            if (lCustomUpdate)
                if (valType(bCustomUpdate)!="B")
                    bCustomUpdate:=&(allTrim(oTFIni:GetPropertyValue(cTableImport,"bCustomUpdate","{|cSourceAlias,cAlias,lFound,lAddNew,cIndexKey,cIndexID,nFields,aTargetFieldsDef,oTLogReport|.F.}")))
                endif
            endif

            lAppendIfNotExist:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"AppendIfNotExist","1"))=="1")
            lUpdateEmptyValue:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"UpdateEmptyValue","0"))=="1")

            bAfterUpdateRecNo:=&(allTrim(oTFIni:GetPropertyValue(cTableImport,"bAfterUpdateRecNo","{|cAlias,nRecNo|.F.}")))
            lAfterUpdateRecNo:=(valType(bAfterUpdateRecNo)=="B")

            bAfterUpdateTable:=&(allTrim(oTFIni:GetPropertyValue(cTableImport,"bAfterUpdateTable","{|cAlias,oTLogReport,oMsNewProcess,oTimeRemaining,oProgress|.F.}")))

            (cSourceAlias)->(dbGoTop())

            nTmpAliasOrder:=(cSourceAlias)->(IndexOrd())

            while (cSourceAlias)->(!eof())
                if ((cSourceAlias)->(!dbEval():GetNextRecNo(@cSourceAlias,@nTmpAliasNextRecNo,@nTmpAliasOrder)))
                    exit
                endif
                cIndexID:=(cSourceAlias)->(&(cIndexKey))
                lFound:=(cTargetAlias)->(dbSeek(cIndexID,.F.))
                begin sequence
                    if ((!lFound).and.(!lAppendIfNotExist))
                        break
                    endif
                    lAddNew:=(!lFound)
                    nRecProcCustom:=1
                    if (lCustomUpdate)
                        lHasError:=(!EvalBlock():EvalBlock(;
                            {||(cTargetAlias)->(;
                                Eval(;
                                    @bCustomUpdate,;
                                    @cSourceAlias,;
                                    @cTargetAlias,;
                                    @lFound,;
                                    @lAddNew,;
                                    @cIndexKey,;
                                    @cIndexID,;
                                    @nFields,;
                                    @aTargetFieldsDef,;
                                    @oTLogReport,;
                                    @nTmpAliasNextRecNo,;
                                    @nTmpAliasOrder,;
                                    @nRecProcCustom;
                                );
                            )},;
                            nil,;
                            .F.,;
                            nil,;
                            nil;
                            );
                        )
                        if (lHasError)
                            cError:=EvalBlockGetValue("ErrorDescription","")
                            cError+=EvalBlockGetValue("ErrorStack","")
                            DelSection("EvalBlock")
                            if (!empty(cError))
                                cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                cError:=""
                                cTLogGroup:="table : ["+cSourceFile+"] foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]:"
                                oTLogReport:AddGroup(cTLogGroup)
                                oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                cTLogDetail:=""
                            endif
                        else
                            nRecProcCustom--
                        endif
                    else
                        if (!lAddNew)
                            lLock:=MySoftLock(cTargetAlias)
                            if (lLock)
                                lLock:=((cTargetAlias)->(MyRecLock(cTargetAlias,lAddNew)))
                            endif
                        else
                           lLock:=((cTargetAlias)->(MyRecLock(cTargetAlias,lAddNew)))
                        endif
                        if (lLock)
                            for nField:=1 to nFields
                                cField:=aTargetFieldsDef[nField][1]
                                if ((lFound).and.(cField$cIndexKey))
                                    loop
                                endif
                                if ((lAddFieldTmp).and.(aScan(aSourceTmpFldStruct,{|e|(e[DBS_NAME]==cField)})>0))
                                    loop
                                endif
                                if ((!oHMTargetFieldsPos:Get(cField,@nTargetFieldPos)).or.(nTargetFieldPos==0))
                                    loop
                                endif
                                xValue:=(cSourceAlias)->(FieldGet(nTargetFieldPos))
                                if (empty(xValue).and.(!lUpdateEmptyValue))
                                    loop
                                endif
                                if ((lMemoVirutal).and.(oHMMemoVirutal:Get(cField,@bUpdateMemoVirtual)))
                                    (cTargetAlias)->(EvalBlock():EvalBlock(bUpdateMemoVirtual))
                                else
                                    (cTargetAlias)->(FieldPut(nTargetFieldPos,xValue))
                                endif
                            next nField
                            if (lAfterUpdateRecNo)
                                lHasError:=(!EvalBlock():EvalBlock({||(cTargetAlias)->(Eval(bAfterUpdateRecNo,cTargetAlias,RecNo()))},nil,.F.,nil,nil))
                                if (lHasError)
                                    cError:=EvalBlockGetValue("ErrorDescription","")
                                    cError+=EvalBlockGetValue("ErrorStack","")
                                    DelSection("EvalBlock")
                                    if (!empty(cError))
                                        cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                                        cError:=""
                                        cTLogGroup:="table : ["+cTargetAlias+"] foram Encontradas inconsistencias na linha ["+cTools():NToS((cTargetAlias)->(recNo()))+"] Processo:["+GetCBSource(bAfterUpdateRecNo)+"]:"
                                        oTLogReport:AddGroup(cTLogGroup)
                                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                                        cTLogDetail:=""
                                    endif
                                endif
                            endif
                            (cTargetAlias)->(msUnLock())
                        endif
                    endif
                end sequence

                while (nRecProcCustom>=1)

                    nRecProcCustom--

                    nRecProc++
                    if (lPercentage)
                        nRecProcPerc:=(nRecProc*nIncProcStep)
                    else
                        nRecProcPerc:=nRecProc
                    endif

                    oTimeRemaining:nProgress:=nRecProc

                    if ((if(lPercentage,(oHMIncProcStep:Get(nRecProc)),(Mod(nRecProcPerc,nIncProcStep)==0))).or.(nRecProcPerc>=nRecCount))
                        oTimeRemaining:Calcule(.F.)
                        cTimeRemaining:=" :: End of processing in ["+oTimeRemaining:GetcTRemaining()+"]["+DtoC(oTimeRemaining:GetdEndTime())+"]"
                        cTimeRemaining+="["+oTimeRemaining:GetcEndTime()+"]"
                        cTimeRemaining+="[+/-]"
                        cTimeRemaining+="["+oTimeRemaining:GetcAverageTime()+"]"
                        cIncProc:="["+oProgress:Eval()+"] "
                        cIncProc+="Updating Record ["
                        cIncProc+=cTools():NToS(nRecProc)
                        cIncProc+="/"
                        cIncProc+=cRecCount
                        cIncProc+="] :: "
                        cIncProc+="Table ["+cTargetAliasRealName+"]"
                        cIncProc+=cTimeRemaining
                        cIncProc+=" :: ["+cTools():NToS(Round(if((nRecProcPerc>=nRecCount),100,((nRecProc/nRecCountProc)*100)),2))+"%]"
                        oMsNewProcess:IncRegua2(cIncProc)
                    endif

                    lEnd:=oMsNewProcess:lEnd

                    if (lEnd)
                        cTLogGroup:="Process canceled by user:"
                        oTLogReport:AddGroup(cTLogGroup)
                        cTLogDetail:="Process canceled by user ["+DtoC(Date())+"]["+Time()+"]"
                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail)
                        exit
                    endif

                end while

                lEnd:=oMsNewProcess:lEnd

                if (lEnd)
                    cTLogGroup:="Process canceled by user:"
                    oTLogReport:AddGroup(cTLogGroup)
                    cTLogDetail:="Process canceled by user ["+DtoC(Date())+"]["+Time()+"]"
                    oTLogReport:AddDetail(cTLogGroup,cTLogDetail)
                    exit
                endif

                if ((cSourceAlias)->(!dbEval():GoToNextRecNo(@cSourceAlias,@nTmpAliasNextRecNo,@nTmpAliasOrder)))
                    exit
                endif

            end while

            for nField:=1 to nFields
                cField:=aTargetFieldsDef[nField][1]
                DelProperty(cField)
            next nField

            if (lEnd)
                break
            endif

            cTLogGroup:="["+cAlias+"/"+cTableImport+"]"

            cTLogDetail:="Data: ["+DToC(oTimeRemaining:GetdStartTime())+"]"
            cTLogDetail+=" "
            cTLogDetail+="Hora: ["+oTimeRemaining:GetcStartTime()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Inicio da Atualizacao dos Dados (Protheus)."
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:="Data: ["+DToC(oTimeRemaining:GetdEndTime())+"]"
            cTLogDetail+=" "
            cTLogDetail+="Hora: ["+oTimeRemaining:GetcEndTime()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Termino da Atualizacao dos Dados (Protheus)."
            cTLogDetail+=" : "
            cTLogDetail+="Decorridos: ["+oTimeRemaining:GetcTimeDiff()+"]"
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:=oTLogReport:ThinLine()
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:="["+oTimeRemaining:GetcTimeDiff()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Tempo de Processamento Atualizacao dos Dados (Protheus)."
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:="Hora: ["+oTimeRemaining:GetcAverageTime()+"]"
            cTLogDetail+=" : "
            cTLogDetail+="Tempo Medio de Processamento Atualizacao dos Dados (Protheus)."
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            cTLogDetail:=oTLogReport:ThinLine()
            oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            if (valType(bAfterUpdateTable)=="B")

                cTime:=Time()

                cTLogGroup:="["+cAlias+"/"+cTableImport+"]"

                cTLogDetail:="Data: ["+DToC(Date())+"]"
                cTLogDetail+=" "
                cTLogDetail+="Hora: ["+Time()+"]"
                cTLogDetail+=" : "
                cTLogDetail+="Inicio das Atualizacoes Complementares (bAfterUpdateTable)."
                oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

                (cTargetAlias)->(dbGoTop())
                lHasError:=(!EvalBlock():EvalBlock(;
                    {||;
                        (cTargetAlias)->(;
                            Eval(;
                                bAfterUpdateTable,;
                                cTargetAlias,;
                                oTLogReport,;
                                oMsNewProcess,;
                                oTimeRemaining,;
                                oProgress;
                            );
                        );
                    },;
                    nil,;
                    .F.,;
                    nil,;
                    nil;
                    );
                )
                if (lHasError)
                    cError:=EvalBlockGetValue("ErrorDescription","")
                    cError+=EvalBlockGetValue("ErrorStack","")
                    DelSection("EvalBlock")
                    if (!empty(cError))
                        cTLogDetail:=cTools():StrReplace(cError,{cCRLF," "})
                        cError:=""
                        cTLogGroup:="table : ["+cAlias+"] foram Encontradas inconsistencias no Processo: ["+GetCBSource(bAfterUpdateTable)+"]:"
                        oTLogReport:AddGroup(cTLogGroup)
                        oTLogReport:AddDetail(cTLogGroup,cTLogDetail,nMLCountSize)
                        cTLogDetail:=""
                    endif
                endif

                cTLogGroup:="["+cAlias+"/"+cTableImport+"]"

                cTLogDetail:="Data: ["+DToC(Date())+"]"
                cTLogDetail+=" "
                cTLogDetail+="Hora: ["+Time()+"]"
                cTLogDetail+=" : "
                cTLogDetail+="Termino das Atualizacoes Complementares (bAfterUpdateTable)."
                cTLogDetail+=" : "
                cTLogDetail+="Decorridos: ["+ElapTime(cTime,Time())+"]"
                oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

                cTLogDetail:=oTLogReport:ThinLine()
                oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

            endif

        end sequence

        if (!lPreLoadTable)
            (cSourceAlias)->(dbCloseArea())
            if (valType(oFWTemporaryTable)=="O")
                oFWTemporaryTable:Delete()
                FreeObj(@oFWTemporaryTable)
            endif
        endif

    end sequence

    SetFilAnt(cSVFilAnt)

    DelSection("EvalBlock")

    FreeObj(@oProgress)
    FreeObj(@oTimeRemaining)
    FreeObj(@oSourceJSONLine)

    if (valType(oFT)=="O")
        oFT:ft_fUse()
        oFT:FreeObj()
        FreeObj(@oFT)
    endif

    if (Type("oPVTHMSR8Seq")=="O")
        oPVTHMSR8Seq:Clean()
        FreeObj(@oPVTHMSR8Seq)
    endif

    if (Type("oPVTHMSRDSeq")=="O")
        oPVTHMSRDSeq:Clean()
        FreeObj(@oPVTHMSRDSeq)
    endif

    if (type("oPVTHMFindSRVPD")=="O")
        oPVTHMFindSRVPD:Clean()
        FreeObj(@oPVTHMFindSRVPD)
    endif

    if (valtype(oHMSourceFieldsDef)=="O")
        oHMSourceFieldsDef:Clean()
        FreeObj(@oHMSourceFieldsDef)
    endif

    if (valtype(oHMTargetFieldsDef)=="O")
        oHMTargetFieldsDef:Clean()
        FreeObj(@oHMTargetFieldsDef)
    endif

    if (valtype(oHMTargetFieldsPos)=="O")
        oHMTargetFieldsPos:Clean()
        FreeObj(@oHMTargetFieldsPos)
    endif

    if (lMemoVirutal)
        if (valtype(oHMMemoVirutal)=="O")
            oHMMemoVirutal:Clean()
            FreeObj(@oHMMemoVirutal)
        endif
    endif

    if (lPercentage)
        if (valtype(oHMIncProcStep)=="O")
            oHMIncProcStep:Clean()
            FreeObj(@oHMIncProcStep)
        endif
    endif

    if (lTypeReplicate)
        FWFreeArray(@aTargetReplicateFields)
        FWFreeArray(@aTargetReplicateFieldsPos)
        if (valtype(oHMTargetReplicateFields)=="O")
            oHMTargetReplicateFields:Clean()
            FreeObj(@oHMTargetReplicateFields)
        endif
    endif

    FWFreeArray(@aLine)
    FWFreeArray(@aField)
    FWFreeArray(@aIncProcStep)

    FWFreeArray(@aFieldsDef)
    FWFreeArray(@aSourceTmpFields)
    FWFreeArray(@aSourceTmpFldStruct)

    FWFreeArray(@aTargetStruct)
    FWFreeArray(@aTargetFieldsDef)
    FWFreeArray(@aReplicateValues)
    FWFreeArray(@aNoReplicateValues)
    FWFreeArray(@aTargetFieldsDefReplicate)

    FWFreeArray(@aUpdateTableFields)
    FWFreeArray(@aUpdateTableSource)

    DelClassIntF()

    Set(_SET_DELETED,if(lDeleted,"ON","OFF"))

return(lImportData)

static function readIniFile(cINIFile as character) as logical

    local cRootPath as character

    local cSPPDrive as character
    local cSPPPath as character
    local cSPPFile as character
    local cSPPExt as character

    local lreadIniFile:=.F. as logical

    local oTFIni as object

    begin sequence

        lreadIniFile:=(!empty(cINIFile).and.(File(cINIFile)))
        if (!lreadIniFile)
            ApMsgAlert("Configuration file invalid or not found","Attention")
            break
        endif

        SplitPath(cINIFile,@cSPPDrive,@cSPPPath,@cSPPFile,@cSPPExt)

        cRootPath:=cSPPDrive
        cRootPath+=cSPPPath

        SetValue("cINIFile",cINIFile)
        SetValue("cRootPath",cRootPath)

        oTFIni:=TFIni():New(cINIFile,"#")

        SetValue("readIniFile",oTFIni)

    end sequence

return(lreadIniFile)

static function readTableDefinition() as logical

    local aLineDef as array
    local aFieldDef as array
    local aFieldsDef:=array(0) as array
    local aFieldDefTmp as array
    local aTablesImport as array

    local cLine as character

    local cTable as character
    local cRootPath as character
    local cTablesDefinition as character
    local cFileTablesDefinition as character

    local lTypeReplicate:=.F. as logical
    local lSkipTable:=.F. as logical
    local lreadTableDefinition:=.F. as logical

    local nField as numeric
    local nFields as numeric

    local nAT as numeric

    local nft_fRecNo as numeric
    local nft_fHandle as numeric

    local nTypeReplicate as numeric

    local oFT as object
    local oTFIni as object
    local oHMTablesImport as object

    begin sequence

        oTFIni:=GetValue("readIniFile")

        aTablesImport:=aClone(oTFIni:GetAllProperties("TablesImport"))
        lreadTableDefinition:=(!empty(aTablesImport))
        if (!lreadTableDefinition)
            ApMsgAlert("Invalid import tables","Attention")
            break
        endif

        cTablesDefinition:=allTrim(oTFIni:GetPropertyValue("Tables","TablesDefinition",""))
        lreadTableDefinition:=(!empty(cTablesDefinition))
        if (!lreadTableDefinition)
            ApMsgAlert("Invalid TablesDefinition","Attention")
            break
        endif

        cRootPath:=GetValue("cRootPath")
        cFileTablesDefinition:=(cRootPath+".."+cTablesDefinition)
        lreadTableDefinition:=file(cFileTablesDefinition)
        if (!lreadTableDefinition)
            ApMsgAlert("File ("+cFileTablesDefinition+") with the definitions of the tables not found","Attention")
            break
        endif

        oFT:=uft():New()

        FWMsgRun(nil,{||nft_fHandle:=oFT:ft_fUse(cFileTablesDefinition)},"Wait...",cFileTablesDefinition)

        lreadTableDefinition:=(nft_fHandle>=0)
        if (!lreadTableDefinition)
            oFT:ft_fUse()
            FreeObj(@oFT)
            ApMsgAlert("Could not open the file: "+cFileTablesDefinition,"Attention")
            break
        endif

        oHMTablesImport:=aToHM(aTablesImport,2)

        oFT:ft_fGoTop()

        while (!oFT:ft_fEof())
            cLine:=oFT:ft_fReadLN()
            if ("-"!=Left(cLine,1))
                oFT:ft_fSkip()
                loop
            endif
            aLineDef:=cTools():StrTokArray(cLine," ")
            exit
        end while

        lreadTableDefinition:=(!empty(aLineDef).and.(len(aLineDef)==DTS_DBS_ALEN))
        if (!lreadTableDefinition)
            ApMsgAlert("Could not get structure for tables","Attention")
            break
        endif

        nAT:=1

        aLineDef[DTS_DBS_NAME]:={;
            nAT,;
            (Len(aLineDef[DTS_DBS_NAME])+1);
        }

        nAT+=aLineDef[DTS_DBS_NAME][2]

        aLineDef[DTS_DBS_TYPE]:={;
            nAT,;
            (Len(aLineDef[DTS_DBS_TYPE])+1);
        }

        nAT+=aLineDef[DTS_DBS_TYPE][2]

        aLineDef[DTS_DBS_FLG]:={;
            nAT,;
            (Len(aLineDef[DTS_DBS_FLG])+1);
        }

        nAT+=aLineDef[DTS_DBS_FLG][2]

        aLineDef[DTS_DBS_FORMAT]:={;
            nAT,;
            Len(aLineDef[DTS_DBS_FORMAT]);
        }

        oFT:ft_fGoTop()

        while (!oFT:ft_fEof())
            cLine:=oFT:ft_fReadLN()
            begin sequence
                if (empty(cLine))
                    break
                endif
                cTable:=""
                if ("Table:"==Left(cLine,6))
                    cTable:=strTran(cLine,"Table:","")
                    cTable:=allTrim(cTable)
                    lSkipTable:=(!oHMTablesImport:Get(cTable))
                    if (lSkipTable)
                        break
                    else
                        oFT:ft_fDelete()
                        oFT:ft_fSkip()
                    endif
                    aSize(aFieldsDef,0)
                    while (!oFT:ft_fEof())
                        cLine:=oFT:ft_fReadLN()
                        if (empty(cLine).or.("Field Name"==Left(cLine,10)).or.("-"==Left(cLine,1)))
                            cLine:=""
                            oFT:ft_fDelete()
                            oFT:ft_fSkip()
                            loop
                        endif
                        if ("Table:"==Left(cLine,6))
                            SetValue(cTable,aClone(aFieldsDef))
                            aSize(aFieldsDef,0)
                            nft_fRecNo:=oFT:ft_fRecNo()
                            oFT:ft_fGoTo(nft_fRecNo-1)
                            break
                        endif
                        cLine:=Accentuation(cLine,.T.)
                        aFieldDef:=Array(DTS_DBS_ALEN)
                        aFieldDef[DTS_DBS_NAME]:=allTrim(SubStr(cLine,aLineDef[DTS_DBS_NAME][1],aLineDef[DTS_DBS_NAME][2]))
                        aFieldDef[DTS_DBS_TYPE]:=allTrim(SubStr(cLine,aLineDef[DTS_DBS_TYPE][1],aLineDef[DTS_DBS_TYPE][2]))
                        aFieldDef[DTS_DBS_FLG]:=allTrim(SubStr(cLine,aLineDef[DTS_DBS_FLG][1],aLineDef[DTS_DBS_FLG][2]))
                        aFieldDef[DTS_DBS_FORMAT]:=allTrim(SubStr(cLine,aLineDef[DTS_DBS_FORMAT][1],aLineDef[DTS_DBS_FORMAT][2]))
                        cLine:=""
                        nTypeReplicate:=AT("[",aFieldDef[DTS_DBS_TYPE])
                        lTypeReplicate:=(nTypeReplicate>0)
                        if (lTypeReplicate)
                            nFields:=val(SubStr(aFieldDef[DTS_DBS_TYPE],(nTypeReplicate+1),(AT("]",aFieldDef[DTS_DBS_TYPE])-1)))
                            aAdd(aFieldsDef,aClone(aFieldDef))
                            if (nFields>1)
                                aFieldDefTmp:=aClone(aFieldDef)
                                SetValue(cTable+"_TypeReplicate",lTypeReplicate)
                                SetValue(aFieldDef[DTS_DBS_NAME]+"_TypeReplicate",nFields)
                                for nField:=2 to nFields
                                    aFieldDef[DTS_DBS_NAME]:=(aFieldDefTmp[DTS_DBS_NAME]+cTools():NToS(nField))
                                    aAdd(aFieldsDef,aClone(aFieldDef))
                                next nField
                                FWFreeArray(@aFieldDefTmp)
                            endif
                        else
                            aAdd(aFieldsDef,aClone(aFieldDef))
                        endif
                        FWFreeArray(@aFieldDef)
                        oFT:ft_fDelete()
                        oFT:ft_fSkip()
                    end while
                    SetValue(cTable,aClone(aFieldsDef))
                    aSize(aFieldsDef,0)
                elseif (lSkipTable)
                    break
                endif
            end sequence
            oFT:ft_fDelete()
            oFT:ft_fSkip()
        end while

    end sequence

    if (valType(oFT)=="O")
        oFT:ft_fUse()
        oFT:FreeObj()
        FreeObj(@oFT)
    endif

    if (valtype(oHMTablesImport)=="O")
        oHMTablesImport:Clean()
        FreeObj(@oHMTablesImport)
    endif

    FWFreeArray(@aLineDef)
    FWFreeArray(@aFieldDef)
    FWFreeArray(@aFieldsDef)
    FWFreeArray(@aFieldDefTmp)
    FWFreeArray(@aTablesImport)

    DelClassIntF()

return(lreadTableDefinition)

static function getTargetFieldValue(lHasError as logical,oTFIni as object,aLine as array,cTargetField as character,aTargetField as array,aSourceFieldsDef as array,oHMSourceFieldsDef as object,cType as character) as variant

    local aValueField as array
    local aSourceField as array

    local bTransform as codeblock

    local cTransform as character
    local cSourceField as character

    local lSourceTransform as logical

    local nLineSize:=Len(aLine) as numeric
    local nSourceField as numeric
    local nSourceFields as numeric
    local nSourceFieldAT as numeric

    local xValue as variant

    begin sequence

        cSourceField:=aTargetField[2]
        lSourceTransform:=("@"==Left(cSourceField,1))
        if (lSourceTransform)
            cSourceField:=SubStr(cSourceField,2)
        endif
        aSourceField:=cTools():StrTokArray(cSourceField,"+")
        nSourceFields:=len(aSourceField)
        aValueField:=Array(nSourceFields,2)
        for nSourceField:=1 to nSourceFields
            cSourceField:=aSourceField[nSourceField]
            if (!oHMSourceFieldsDef:Get(cSourceField,@cType))
                loop
            endif
            if (!oHMSourceFieldsDef:Get(cSourceField+"_AT",@nSourceFieldAT))
                loop
            endif
            lHasError:=(nSourceFieldAT>nLineSize)
            if (lHasError)
                break
            endif
            aValueField[nSourceField][1]:=NormalizeData(;
                @lHasError,;
                aLine[nSourceFieldAT],;
                @cType,;
                @cSourceField,;
                @lSourceTransform,;
                @st_oHMbTransform,;
                @oTFIni;
            )
            if (lHasError)
                break
            endif
            aValueField[nSourceField][2]:=cType
            if (cType=="char")
                xValue:=""
            endif
        next nSourceField

        for nSourceField:=1 to nSourceFields
            if (aValueField[nSourceField][2]=="char")
                xValue+=aValueField[nSourceField][1]
            else
                xValue:=aValueField[nSourceField][1]
            endif
        next nSourceField

        if (!st_oHMbTransform:Get(cTargetField,@bTransform))
            cTransform:=allTrim(oTFIni:GetPropertyValue(cTargetField,"Transform",""))
            if (cTransform=="FindInTable")
                cTransform:=allTrim(oTFIni:GetPropertyValue(cTargetField,cTransform,""))
                lHasError:=(!EvalBlock():EvalBlock({||bTransform:=&(cTransform)},nil,.F.,nil,nil))
            elseif (!empty(cTransform))
                lHasError:=(!EvalBlock():EvalBlock({||bTransform:=&(cTransform)},nil,.F.,nil,nil))
            endif
            st_oHMbTransform:Set(cTargetField,bTransform)
        endif

        if (valtype(bTransform)=="B")
            lHasError:=(!EvalBlock():EvalBlock({||xValue:=Eval(bTransform,xValue,@oTFIni,@cType)},nil,.F.,nil,nil))
        endif

    end sequence

    SetValue(cTargetField,xValue)

    FWFreeArray(@aValueField)
    FwFreeArray(@aSourceField)

return(xValue)

static function NormalizeData(lHasError as logical,xValue as variant,cType as character,cSourceField as character,lSourceTransform as logical,st_oHMbTransform as object,oTFIni as object) as variant

    local bTransform as codeblock

    local cTransform as character

    if (lSourceTransform)
        if (!st_oHMbTransform:Get(cSourceField,@bTransform))
            cTransform:=allTrim(oTFIni:GetPropertyValue(cSourceField,"Transform",""))
            if (cTransform=="FindInTable")
                cTransform:=allTrim(oTFIni:GetPropertyValue(cSourceField,cTransform,""))
                lHasError:=(!EvalBlock():EvalBlock({||bTransform:=&(cTransform)},nil,.F.,nil,nil))
            elseif (!empty(cTransform))
                lHasError:=(!EvalBlock():EvalBlock({||bTransform:=&(cTransform)},nil,.F.,nil,nil))
            endif
            if (!lHasError)
                st_oHMbTransform:Set(cSourceField,bTransform)
            endif
        endif
        if (valtype(bTransform)=="B")
            lHasError:=(!EvalBlock():EvalBlock({||xValue:=Eval(bTransform,xValue,oTFIni,@cType)},nil,.F.,nil,nil))
            if (!lHasError)
                xValue:=NormalizeData(@lHasError,xValue,@cType,nil,.F.,nil,nil)
            endif
        endif
    else
        if (valType(xValue)=="C")
            if ("char"$cType)
                xValue:=strTran(xValue,'"',"")
            elseif ("inte"$cType)
                xValue:=Int(val(xValue))
            elseif ("deci"$cType)
                if (","$xValue)
                    xValue:=strTran(xValue,",",".")
                endif
                xValue:=val(xValue)
            elseif ("date"$cType)
                xValue:=CToD(xValue)
            elseif ("logi"$cType)
                xValue:=(Left(lower(xValue),1)$"sty1")
            endif
        endif
    endif

return(xValue)

static function FindInTable(oTFIni as object,cTable as character,xValue as variant,lTableInFile as logical,lUseDFV as logical)

    local cType as character

    local cINIFile as character
    local cRootPath as character

    local oTFIniTable as object

    local xTmp as variant

    cType:=valType(xValue)
    if (cType=="N")
        xValue:=ctools():NToS(xValue)
    elseif (cType!="C")
        xValue:=cValToChar(xValue)
    endif

    dfv():Default(@lUseDFV,.T.)

    if ((oTFIniTable:=GetHMValue(cTable,nil))!=nil)
        xTmp:=oTFIniTable:GetPropertyValue(cTable,xValue,"")
        if ((lUseDFV).and.(empty(xTmp)).and.((oTFIniTable:GetATProperty(cTable,"__DFV__")>0)))
            xTmp:=oTFIniTable:GetPropertyValue(cTable,"__DFV__","")
        endif
        xValue:=xTmp
    elseif (oTFIni:ExistSection(cTable))
        if (oTFIni:GetATProperty(cTable,"FindInTableFile")>0)
            dfv():Default(@lTableInFile,.F.)
            if (lTableInFile)
                cRootPath:=GetValue("cRootPath")
                cINIFile:=cRootPath
                cINIFile+=oTFIni:GetPropertyValue(cTable,"FindInTableFile","")
                oTFIniTable:=TFIni():New(cINIFile,"#")
                SetHMValue(cTable,oTFIniTable)
                xTmp:=oTFIniTable:GetPropertyValue(cTable,xValue,"")
                if ((lUseDFV).and.(empty(xTmp)).and.((oTFIniTable:GetATProperty(cTable,"__DFV__")>0)))
                    xTmp:=oTFIniTable:GetPropertyValue(cTable,"__DFV__","")
                endif
                xValue:=xTmp
            else
                cRootPath:=GetValue("cRootPath")
                cINIFile:=cRootPath
                cINIFile+=oTFIni:GetPropertyValue(cTable,"FindInTableFile","")
                oTFIniTable:=TFIni():New(cINIFile,"#")
                SetValue(cTable,oTFIniTable)
                xTmp:=oTFIniTable:GetPropertyValue(cTable,xValue,"")
                if ((lUseDFV).and.(empty(xTmp)).and.((oTFIniTable:GetATProperty(cTable,"__DFV__")>0)))
                    xTmp:=oTFIniTable:GetPropertyValue(cTable,"__DFV__","")
                endif
                xValue:=xTmp
            endif
        else
            xTmp:=oTFIni:GetPropertyValue(cTable,xValue,"")
            if ((lUseDFV).and.(empty(xTmp)).and.((oTFIni:GetATProperty(cTable,"__DFV__")>0)))
                xTmp:=oTFIni:GetPropertyValue(cTable,"__DFV__","")
            endif
            xValue:=xTmp
        endif
    endif

return(xValue)

static function ProcRedefine(oProcess as object,oTFont as object,nLeft as numeric,nWidth as numeric,nCTLFLeft as numeric,loTDlgF as logical,loTDlgW as logical,lPercentage as logical,lFastMode as logical) as logical
    local lProcRedefine as logical
    lProcRedefine:=MsProcess():ProcRedefine(@oProcess,@oTFont,@nLeft,@nWidth,@nCTLFLeft,@loTDlgF,@loTDlgW,lPercentage,lFastMode)
    return(lProcRedefine)

static function SetFilAnt(cFil as character)
    local cSvFilAnt:=&("cFilAnt") as character
    if (valType("cFilAnt")=="C")
        cSvFilAnt:=&("cFilAnt")
        if (cFil!=cSvFilAnt)
            &("cFilAnt"):=cFil
            FWSM0Util():setSM0PositionBycFilAnt()
        endif
    endif
return(cSvFilAnt)

static procedure CFGFile()

    local cINIFile as character
    local cMemoEdit as character
    local cGetFileRoot as character
    local cGetFileMask as character
    local cGetFileTitle as character

    local lHasINIFile as logical

    local nGetFileOptions as numeric

    local oTFIni as object

    begin sequence

        cGetFileRoot:=GetValue("cRootPath")

        cGetFileMask:=cTools():Accentuation("Arquivo de Configura#1#2o | *.ini","ccedil","atilde")
        cGetFileTitle:=cTools():Accentuation("Arquivo de Configura#1#2o *.ini","ccedil","atilde")
        nGetFileOptions:=(GETF_LOCALHARD+GETF_NETWORKDRIVE)
        cINIFile:=cGetFile(cGetFileMask,cGetFileTitle,1,cGetFileRoot,.F.,nGetFileOptions,/*[lArvore]*/,/*[lKeepCase]*/)

        lHasINIFile:=File(cINIFile)
        if (!lHasINIFile)
            break
        endif

        cMemoEdit:=ReadMemoCFGFile(cINIFile)

        if (EdtCFGFile(@cINIFile,@cMemoEdit))
            if (!("datasul2protheus.ini"$lower(cINIFile)))
                cINIFile:=GetValue("cINIFile")
            endif
            oTFIni:=GetValue("readIniFile")
            if (valType(oTFIni)=="O")
                FWMsgRun(nil,{||oTFIni:FreeObj()},"Wait...","Releasing temporary files and workspace memory...")
                if (valType(oTFIni)=="O")
                    FreeObj(@oTFIni)
                endif
            endif
            DelSection("datasul2totvsprotheus")
            if (valType(st_oHMbTransform)=="O")
                st_oHMbTransform:Clean()
            endif
            FWMsgRun(nil,{||datasul2totvs.readIniFile(@cINIFile)},"Wait...","Wait! Loading Settings","["+cINIFile+"]")
            FWMsgRun(nil,{||lActivate:=datasul2totvs.readTableDefinition()},"Loading structure of tables","Wait...")
        endif

    end sequence

    return

static function EdtCFGFile(cINIFile as character,cMemoEdit as character) as logical

    local aButtons as array
    local aAdvSize as array
    local aObjSize as array
    local aObjCoords as array
    local aInfoAdvSize as array

    local bSet15 as codeblock
    local bSet24 as codeblock
    local bNotepadCFGFile as codeblock
    local bRestoreCFGFile as codeblock

    local cTitle as character
    local cSVMemoEdit as character

    local lOk as logical

    local nDlgWidth as numeric

    local oTDlg as object
    local oTFont as object
    local oTPanel as object
    local oTMemoEdit as object

    dfv():Default(@cMemoEdit,"")

    cSVMemoEdit:=cMemoEdit

    begin sequence

        aAdvSize:=MsAdvSize()
        aInfoAdvSize:={aAdvSize[1],aAdvSize[2],aAdvSize[3],aAdvSize[4],0,0}
        aObjCoords:=array(0)
        aAdd(aObjCoords,{0,0,.T.,.T.})
        aObjSize:=MsObjSize(aInfoAdvSize,aObjCoords)

        cTitle:="ARQUIVO CONFIGURACAO "
        cTitle+=" :: "
        cTitle+=cINIFile

        DEFINE FONT oTFont NAME "Courier New" SIZE 0,-11 BOLD
        DEFINE MSDIALOG oTDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL

            nDlgWidth:=__DlgWidth(oTDlg)

            oTPanel:=tPanel():New(0,0,"",oTDlg,nil,nil,nil,nil,nil,nDlgWidth,nDlgWidth)

            @(aObjSize[1][1]+5),(aObjSize[1][2]+5) GET oTMemoEdit VAR cMemoEdit MEMO SIZE ((aObjSize[1][4]/100)*99),((aObjSize[1][3]/100)*88) FONT oTFont CENTERED DESIGN OF oTPanel PIXEL WHEN (.T.)

            oTMemoEdit:lReadOnly:=.F.
            oTMemoEdit:EnableVScroll(.T.)
            oTMemoEdit:EnableHScroll(.T.)

            oTDlg:lEscClose:=.F.

            bSet15:={||lOk:=ChgCFGFile(@cINIFile,@cMemoEdit,@cSVMemoEdit),if(lOk,oTDlg:End(),lOK)}
            bSet24:={||lOK:=.F.,oTDlg:End()}

            aButtons:=array(0)
            bNotepadCFGFile:={||MsProcess():MsAguarde({||datasul2totvs.NotepadCFGFile(cINIFile)},"Abrindo no Notepad","Aguarde...")}
            aAdd(aButtons,{"NotepadCFGFile",bNotepadCFGFile,OemToAnsi("Abir no Notepad"),OemtoAnsi("Abir no Notepad")})
            bRestoreCFGFile:={||MsProcess():MsAguarde({||datasul2totvs.RestoreCFGFile(cINIFile,@cMemoEdit,@oTMemoEdit,@cSVMemoEdit)},"Restaurando Versao Anterior","Aguarde...")}
            aAdd(aButtons,{"RestoreCFGFile",bRestoreCFGFile,OemToAnsi("Restaurar Versao Anterior"),OemtoAnsi("Restaurar Versao Anterior")})

        ACTIVATE MSDIALOG oTDlg CENTERED ON INIT EnchoiceBar(oTDlg,bSet15,bSet24,nil,@aButtons)

    end sequence

    FreeObj(@oTDlg)
    FreeObj(@oTFont)
    FreeObj(@oTPanel)
    FreeObj(@oTMemoEdit)

    FWFreeArray(@aButtons)
    FWFreeArray(@aAdvSize)
    FWFreeArray(@aObjSize)
    FWFreeArray(@aObjCoords)
    FWFreeArray(@aInfoAdvSize)

    return(lOk)

static function ChgCFGFile(cINIFile as character,cMemoEdit as character,cSVMemoEdit as character) as logical

    local cMsg as character
    local cTitle as character

    local cSPDriver as character
    local cSPPath as character
    local cSPFileName as character
    local cSPFileExt as character

    local cFWWSBKP as character

    local lFilial as logical
    local lEmpresa as logical
    local lChgCFGFile as logical

    local nAttemps as numeric

    lFilial:=(type("cFilAnt")=="C")
    lEmpresa:=(type("cEmpAnt")=="C")

    begin sequence

        lChgCFGFile:=(cMemoEdit==cSVMemoEdit)
        if (lChgCFGFile)
            break
        endif

        cSPDriver:=""
        cSPPath:=""
        cSPFileName:=""
        cSPFileExt:=""

        SplitPath(cINIFile,@cSPDriver,@cSPPath,@cSPFileName,@cSPFileExt)

        cMsg:="Deseja Gravar as Alteracoes?"

        cTitle:="ARQUIVO CONFIGURACAO  :: "
        cTitle+=cSPFileName

        lChgCFGFile:=ApMsgYesNo(cMsg,cTitle)
        if (!lChgCFGFile)
            break
        endif

        cFWWSBKP:=cSPDriver
        cFWWSBKP+=cSPPath
        cFWWSBKP+=cSPFileName
        cFWWSBKP+=cSPFileExt
        cFWWSBKP+="-"
        cFWWSBKP+=__cUserID
        cFWWSBKP+="-"
        cFWWSBKP+=DToS(Date())
        cFWWSBKP+="-"
        cFWWSBKP+=strTran(Time(),":","-")
        cFWWSBKP+="-"
        cFWWSBKP+=strZero(ranDomize(1,999),3)

        nAttemps:=0

        cMsg:="O arquivo "
        cMsg+=cINIFile
        cMsg+=" encontra-se em uso deseja tentar novamente?"

        while (!LockByName(cSPFileName,lEmpresa,lFilial,.T.))
            if (nAttemps++>10)
                nAttemps:=0
                if (!MsgYesNo(cMsg,cTitle))
                    lChgCFGFile:=.F.
                    cMsg:="O arquivo "
                    cMsg+=cINIFile
                    cMsg+=" encontra-se em uso e nao podera ser salvo."
                    ApMsgAlert(cMsg,cTitle)
                    break
                endif
            endif
            sleep(300)
        end while

        nAttemps:=0

        while (file(cINIFile))
            if (fRename(cINIFile,cFWWSBKP))
                exit
            endif
            if (nAttemps++>10)
                nAttemps:=0
                if (!MsgYesNo(cMsg,cTitle))
                    UnlockByName(cSPFileName,lEmpresa,lFilial,.T.)
                    lChgCFGFile:=.F.
                    cMsg:="Problema na gravacao do arquivo : "
                    cMsg+=cINIFile
                    ApMsgAlert(cMsg,cTitle)
                    break
                endif
            endif
            sleep(300)
        end while

        nAttemps:=0

        cMsg:="Problema na gravacao do arquivo : "
        cMsg+=cINIFile
        cMsg+=" Deseja tentar novamente?"

        while (!(lChgCFGFile:=MemoWrite(cINIFile,cMemoEdit)))
            if (nAttemps++>10)
                nAttemps:=0
                if (!MsgYesNo(cMsg,cTitle))
                    exit
                endif
            endif
            sleep(300)
        end while

        UnlockByName(cSPFileName,lEmpresa,lFilial,.T.)

        if (!lChgCFGFile)
            cMsg:="Problema na gravacao do arquivo : "
            cMsg+=cINIFile
            ApMsgAlert(cMsg,cTitle)
            break
        endif

        cMsg:="Arquivo "
        cMsg+=cINIFile
        cMsg+=" salvo com sucesso."
        ApMsgInfo(cMsg,cTitle)

    end sequence

    return(lChgCFGFile)

static procedure NotepadCFGFile(cINIFile as character)

    local cSPDriver as character
    local cSPPath as character
    local cSPFileName as character
    local cSPFileExt as character

    local cTempPath as character
    local cTempFile as character

    cSPDriver:=""
    cSPPath:=""
    cSPFileName:=""
    cSPFileExt:=""

    SplitPath(cINIFile,@cSPDriver,@cSPPath,@cSPFileName,@cSPFileExt)

    cTempPath:=getTempPath()
    if (!(right(cTempPath,1)=="\"))
        cTempPath+="\"
    endif

    cTempFile:=cTempPath
    cTempFile+=cSPFileName
    cTempFile+=cSPFileExt

    if (__CopyFile(cINIFile,cTempFile))
        ShellExecute("open",cTempFile,"","",SW_SHOW)
    endif

    return

static function RestoreCFGFile(cINIFile as character,cMemoEdit as character,oTMemoEdit as object,cSVMemoEdit as character) as logical

    local cMask as character
    local cTitle as character
    local cFileRead as character
    local cDirectory as character

    local cSPDriver as character
    local cSPPath as character
    local cSPFileName as character
    local cSPFileExt as character

    local lRestoreCFGFile as logical

    local nOptions as numeric

    begin sequence

        cSPDriver:=""
        cSPPath:=""
        cSPFileName:=""
        cSPFileExt:=""

        SplitPath(cINIFile,@cSPDriver,@cSPPath,@cSPFileName,@cSPFileExt)

        cMask:="Arquivos de Configuracao|"+cSPFileName+"*"
        cTitle:="Restaurar arquivo de Configuracao"
        cDirectory:=cSPDriver
        cDirectory+=cSPPath
        cDirectory:=StrTran(cSPPath,"/","\")
        nOptions:=GETF_NOCHANGEDIR

        cFileRead:=cGetFile(cMask,cTitle,1,cDirectory,.F.,nOptions,/*[lArvore]*/,/*[lKeepCase]*/)

        if (empty(cFileRead))
            break
        endif

        cFileRead:=(cDirectory+cFileRead)
        cFileRead:=StrTran(cFileRead,"\\","\")

        if (!file(cFileRead))
            break
        endif

        cSvMemoEdit:=cMemoEdit
        cMemoEdit:=ReadMemoCFGFile(cFileRead)

        lRestoreCFGFile:=ChgCFGFile(@cINIFile,@cMemoEdit,@cSVMemoEdit)

        if (!lRestoreCFGFile)
            cMemoEdit:=cSvMemoEdit
            break
        endif

        cSvMemoEdit:=cMemoEdit

        oTMemoEdit:Refresh()

    end sequence

    return(lRestoreCFGFile)

static function ReadMemoCFGFile(cFile) as character
    local cMemoRead as character
    cMemoRead:=cTools():ReadMemo(cFile)
    return(cMemoRead)

static function sendDataToServer(cGetFileRoot as character,lReloadConfig as logical) as logical

    local aZipFiles:=array(0) as array

    local aFiles as array
    local aDirectories as array

    local bNotSend as codeblock

    local cINIFile as character
    local cErrorMsg as character
    local cGetFileMask:="" as character
    local cGetFileTitle as character
    local cDirectoryClient as character
    local cDirectoryServer as character

    local lSendDataToServer as logical

    local nGetFileOptions as numeric

    begin sequence

        lSendDataToServer:=(getComputerName()$(GetNewPar("TOTVSD2PCN","DNA-CSDJ-01")))
        if (!lSendDataToServer)
            break
        endif

        cGetFileTitle:=cTools():Accentuation("Diret#1rio de Configura#2#3o DataSul2Protheus.ini","oacute","ccedil","atilde")
        nGetFileOptions:=(GETF_LOCALHARD+GETF_NETWORKDRIVE+GETF_RETDIRECTORY)
        cDirectoryClient:=cGetFile(cGetFileMask,cGetFileTitle,1,".\",.F.,nGetFileOptions,/*[lArvore]*/,/*[lKeepCase]*/)

        lSendDataToServer:=((lIsDir(cDirectoryClient)).and.("datasul2protheus"$StrTran(lower(cDirectoryClient),"totvs","")))
        if (!lSendDataToServer)
            if (ApMsgYesNo("Invalid directory ["+cDirectoryClient+"]. Want to try again?"))
                lSendDataToServer:=sendDataToServer(@cGetFileRoot)
            elseif (file("\datasul2Protheus\ini\DataSul2Protheus.ini"))
                cGetFileRoot:="SERVIDOR\datasul2protheus\ini\"
            endif
            break
        elseif (file("\datasul2Protheus\ini\DataSul2Protheus.ini"))
            cGetFileRoot:="SERVIDOR\datasul2protheus\ini\"
        endif

        cDirectoryServer:="\datasul2Protheus\"
        DirTools():MakeFileDir(cDirectoryServer)
        lSendDataToServer:=lIsDir(cDirectoryServer)
        if (!lSendDataToServer)
            ApMsgAlert("Invalid directory ["+cDirectoryServer+"]")
            break
        endif

        bNotSend:={|cLowerDirectory|(;
            ("7z"$cLowerDirectory);
            .or.;
            ("src"$cLowerDirectory);
            .or.;
            (".gitignore"$cLowerDirectory);
            .or.;
            (".vscode"$cLowerDirectory);
            .or.;
            ("resource"$cLowerDirectory);
            .or.;
            ("ps"$cLowerDirectory);
            .or.;
            ("auth"$cLowerDirectory);
            )}
        lSendDataToServer:=fileTools():SendDataToServerWithZip(@cDirectoryClient,@cDirectoryServer,@bNotSend,@cErrorMsg)
        if (!lSendDataToServer)
            ApMsgAlert(cErrorMsg)
            break
        endif

        cGetFileRoot:="SERVIDOR"+cDirectoryServer

        ApMsgInfo("Files uploaded to the server successfully. Directory ["+cGetFileRoot+"]")

        cGetFileRoot+="ini\"

    end sequence

    FWFreeArray(@aFiles)
    FWFreeArray(@aZipFiles)
    FWFreeArray(@aDirectories)

    if (lSendDataToServer)
        dfv():Default(@lReloadConfig,.F.)
        if (lReloadConfig)
            DelSection("datasul2totvsprotheus")
            if (valType(st_oHMbTransform)=="O")
                st_oHMbTransform:Clean()
            endif
            cINIFile:="\datasul2Protheus\ini\DataSul2Protheus.ini"
            FWMsgRun(nil,{||datasul2totvs.readIniFile(@cINIFile)},"Wait...","Wait! Loading Settings","["+cINIFile+"]")
            FWMsgRun(nil,{||lActivate:=datasul2totvs.readTableDefinition()},"Loading structure of tables","Wait...")
        endif
    endif

return(lSendDataToServer)

static function MySoftLock(cAlias as character) as logical
    local lLock as logical
    lLock:=(cAlias)->(MyRecLock(cAlias,.F.,.F.,.T.,.T.))
    return(lLock)

static function MyRecLock(cAlias,lAdd,lDelete,lSoft,lInJob)
    local lLock as logical
    ForceAsBlind(.T.)
        dfv():DefaultEmpty(@lDelete,.F.)
        dfv():DefaultEmpty(@lSoft,.F.)
        dfv():DefaultEmpty(@lInJob:=.T.)
        lLock:=(cAlias)->(RecLock(cAlias,lAdd,lDelete,lSoft,lInJob))
    ForceAsBlind(.F.)
return(lLock)

static function ForceAsBlind(lIsBlind as logical) as logical
    if (valtype(lIsBlind)=="L")
        if (!lIsBlind)
            __cInternet:=nil
            HelpInDark(.F.)
        endif
    else
        lIsBlind:=IsBlind()
        if (!lIsBlind)
            __cInternet:="AUTOMATICO"
            HelpInDark(.T.)
        endif
    endif
return(lIsBlind)

static function GetRecCount(cTable as character, cWhere as character) as numeric
return(dbEval():SQLRecCount(@cTable,@cWhere))

static function TCSQLUpdateTable(;
        cSourceAlias as character,;
        cSourceTable as character,;
        cTargetAlias as character,;
        cTargetTable as character,;
        aTargetFieldsDef as array,;
        aTargetFieldsKeys as array,;
        aSourceTmpFldStruct as array,;
        oMsNewProcess as object,;
        oTLogReport as object,;
        oProgress as object;
    ) as numeric

    local cTime:=Time()
    local cMsProcTXT as character
    local cTLogGroup:=ProcName();
          +" :: ";
          +"["+cSourceTable+"]";
          +" => ";
          +"["+cTargetTable+"]";
          +":" as character
    local cTLogDetail as character

    local bSetRegua:={|nRecCount|;
        cTLogDetail:="Data: ["+DToC(Date())+"]",;
        cTLogDetail+=" ",;
        cTLogDetail+="Hora: ["+cTime+"]",;
        cTLogDetail+=" : ",;
        cTLogDetail+="Inicio do Update de Dados.",;
        oTLogReport:AddDetail(cTLogGroup,cTLogDetail),;
        oMsNewProcess:SetRegua2(nRecCount);
    } as codeblock
    local bIncRegua:={|nMinRecNo,nMaxRecNo,nMinRecNoPlus|;
            cMsProcTXT:="["+oProgress:Eval()+"] ",;
            cMsProcTXT+="Updating records from ",;
            cMsProcTXT+="["+cTools():NToS(nMinRecNo)+"] ",;
            cMsProcTXT+="to ",;
            cMsProcTXT+="["+cTools():NToS(Min(nMaxRecNo,nMinRecNoPlus))+"] ",;
            cMsProcTXT+="out of ",;
            cMsProcTXT+="["+cTools():NToS(nMaxRecNo)+"]",;
            MsProcess():MsProcTxt(cMsProcTXT,.T.),;
            oMsNewProcess:IncRegua2(cMsProcTXT);
    } as codeblock
    local bOnError:={|cQueryFull,cSourceTable,cTargetTable,nTCSQLExec,cTCSQLError|;
        cTLogDetail:="TCSQLExec ["+cTools():NToS(nTCSQLExec)+"]",;
        oTLogReport:AddDetail(cTLogGroup,cTLogDetail),;
        cTLogDetail:=cTCSQLError,;
        cTCSQLError:="",;
        oTLogReport:AddDetail(cTLogGroup,cTLogDetail),;
        cTLogDetail:="";
    } as codeblock

    local nTCSQLExec as numeric

    nTCSQLExec:=dbEval():TCSQLUpdateFromTable(;
        @cSourceAlias,;
        @cSourceTable,;
        @cTargetAlias,;
        @cTargetTable,;
        @aTargetFieldsDef,;
        @aTargetFieldsKeys,;
        @aSourceTmpFldStruct,;
        .F./*lSourceKeepRegs*/,;
        @bSetRegua,;
        @bIncRegua,;
        @bOnError;
    )

    cTLogDetail:="Data: ["+DToC(Date())+"]"
    cTLogDetail+=" "
    cTLogDetail+="Hora: ["+Time()+"]"
    cTLogDetail+=" : "
    cTLogDetail+="Termino do Update de Dados."
    cTLogDetail+=" : "
    cTLogDetail+="Decorridos: ["+ElapTime(cTime,Time())+"]"
    oTLogReport:AddDetail(cTLogGroup,cTLogDetail)

return(nTCSQLExec)

static function Accentuation(cText as character,lTablesEncodeUTF8 as logical) as character

    local cCHR128 as character
    local cCHR135 as character
    local cCHR144 as character
    local cCHR162 as character
    local cCHR163 as character
    local cCHR182 as character
    local cCHR194 as character
    local cCHR195 as character
    local cCHR198 as character
    local cCHR199 as character
    local cCHR201 as character
    local cCHR205 as character
    local cCHR214 as character
    local cCHR227 as character
    local cCHR231 as character
    local cCHR243 as character
    local cCHR250 as character

    local cTextNew as character

    if (lTablesEncodeUTF8)
        cTextNew:=DecodeUTF8(cText)
    endif

    if (empty(cTextNew))
        cCHR128:=chr(128)
        cCHR135:=chr(135)
        cCHR144:=chr(144)
        cCHR162:=chr(162)
        cCHR163:=chr(163)
        cCHR182:=chr(182)
        cCHR194:=chr(194)
        cCHR195:=chr(195)
        cCHR198:=chr(198)
        cCHR199:=chr(199)
        cCHR201:=chr(201)
        cCHR205:=chr(205)
        cCHR214:=chr(214)
        cCHR227:=chr(227)
        cCHR231:=chr(231)
        cCHR243:=chr(243)
        cCHR250:=chr(250)
        cTextNew:=cTools():StrReplace(;
            cText,;
            {cCHR144,cCHR201},;
            {cCHR214,cCHR205},;
            {cCHR199,cCHR195},;
            {cCHR128,cCHR199},;
            {cCHR182,cCHR194},;
            {cCHR135,cCHR231},;
            {cCHR198,cCHR227},;
            {cCHR162,cCHR243},;
            {cCHR163,cCHR250};
        )
    endif

return(cTextNew)

static function GetLineFromSource(cLine as character,nLine as numeric,nFileSize as numeric,nBufferSize as numeric,nBytesRead as numeric,cSourceFile as character,lChkEncode as logical,lTablesEncodeUTF8 as logical,oProgress as object,lSetRegua as logical,nSetRegua as numeric,cCRLF as character) as array

    local aLine as array
    local cLineMsg as character
    local nLineSiz as numeric
    local nIncProc as numeric

    if (lChkEncode)
        cLine:=Accentuation(cLine,lTablesEncodeUTF8)
    endif

    aLine:=cTools():StrTokArray(cLine,";")

    if ((lSetRegua).and.(nSetRegua==0).and.(!Empty(aLine)))
        lSetRegua:=.F.
        nLineSiz:=0
        nSetRegua:=(nBufferSize/nFileSize)
        aEval(aLine,{|e|nLineSiz+=(Len(e)+1+nSetRegua)})
        nLineSiz-=1
        nSetRegua:=nLineSiz
        nSetRegua:=Int(nFileSize/nSetRegua)
        MsProcess():SetRegua(nSetRegua,.T.)
    endif

    cLineMsg:="["+oProgress:Eval()+"] ["+cSourceFile+"]"
    cLineMsg+=cCRLF
    cLineMsg+=cCRLF
    cLineMsg+="Bytes  Processados ["+StrZero(Min(nFileSize,nBytesRead),16)+"/"+StrZero(nFileSize,16)+"]"
    nIncProc:=if((nBytesRead>=nFileSize),100,((nBytesRead/nFileSize)*100))
    cLineMsg+="["+cTools():NToS(nIncProc)+"%]"
    cLineMsg+=cCRLF
    cLineMsg+="Linhas Processadas ["+StrZero(Min(nSetRegua,nLine),16)+"/"+StrZero(nSetRegua,16)+"]"
    nIncProc:=if((nLine>=nSetRegua),100,((nLine/nSetRegua)*100))
    cLineMsg+="["+cTools():NToS(nIncProc)+"%]"

    MsProcess():MsProcTxt(cLineMsg,.T.)

return(aLine)

static function GetDataPath() as character

    local cRootPath as character
    local cDataPath as character

    local oTFIni:=GetValue("readIniFile") as object

    cDataPath:=allTrim(oTFIni:GetPropertyValue("Tables","TablesData",""))

    cRootPath:=GetValue("cRootPath")
    cDataPath:=(cRootPath+".."+cDataPath)

return(cDataPath)

static function GetDataPathSplit() as character

    local cRootPath as character
    local cDataPath as character

    local oTFIni:=GetValue("readIniFile") as object

    cDataPath:=allTrim(oTFIni:GetPropertyValue("Tables","TablesDataSplit",""))
    cRootPath:=GetValue("cRootPath")
    cDataPath:=(cRootPath+".."+cDataPath)

return(cDataPath)

static function SplitOptions(nSplitSize as numeric) as logical

    local aPBoxPrm:=Array(0) as array
    local aPBoxRet:=Array(0) as array

    local cPBoxTit:=OemToAnsi("Informe os parametros") as character

    local lParamBox:=.F. as logical

    local nPBox as numeric

    saveInter()

        aAdd(aPBoxPrm,Array(9))
        nPBox:=Len(aPBoxPrm)
        //01----------------------------------------------------------------------------------------------
        aPBoxPrm[nPBox][1]:=1                 //[1]:1 - MsGet
        aPBoxPrm[nPBox][2]:="Tamanho em MB"   //[2]:Descricao
        aPBoxPrm[nPBox][3]:=nSplitSize        //[3]:String contendo o inicializador do campo
        aPBoxPrm[nPBox][4]:="99"              //[4]:String contendo a Picture do campo
        aPBoxPrm[nPBox][5]:="NaoVazio()"      //[5]:String contendo a validacao
        aPBoxPrm[nPBox][6]:=""                //[6]:Consulta F3
        aPBoxPrm[nPBox][7]:="AllWaysTrue()"   //[7]:String contendo a validacao When
        aPBoxPrm[nPBox][8]:=CalcFieldSize("N",Len(aPBoxPrm[nPBox][4]),0,aPBoxPrm[nPBox][4],aPBoxPrm[nPBox][2]) //[8]:Tamanho do MsGet
        aPBoxPrm[nPBox][9]:=.F.               //[9]:Flag .T./.F. Parametro Obrigatorio ?

        while (!(lParamBox:=ParamBox(@aPBoxPrm,@cPBoxTit,@aPBoxRet,nil,nil,.T.,nil,nil,nil,nil,.T.,.T.)))
            lParamBox:=MsgYesNo(cTools():Accentuation("Deseja Cancelar a Altera#1#2o dos Par#3metros?","ccedil","atilde","acirc"),cTools():Accentuation("Aten#1#2o!","ccedil","atilde"))            
            if (lParamBox)
                lParamBox:=.F.
                exit
            endif
        end while

        if (lParamBox)
            nSplitSize:=aPBoxRet[nPBox]
        endif

    restInter()

    FWFreeArray(@aPBoxRet)
    FWFreeArray(@aPBoxPrm)

return(lParamBox)

static function SplitFileAdd(cSourceTable as character) as logical

    local aFiles as array

    local cLogFile as character
    local cDataPath as character
    local cTargetPath as character

    local cSPPDrive as character
    local cSPPPath as character
    local cSPPFile as character
    local cSPPExt as character

    local cHTML as character
    local cBaseURL as character
    local cHTMLTempFile as character

    local lSplitFile as logical

    local nFile as numeric
    local nFiles as numeric
    local nSplitSize:=10 as numeric

    local oUFLog:=uf.log.Log():New() as object

    begin sequence

        cDataPath:=GetDataPath()
        lSplitFile:=(!empty(cDataPath))
        if (!lSplitFile)
            ApMsgAlert("Invalida Data Path ("+cDataPath+")","Attention")
            break
        endif

        cSourceFile:=(cDataPath+cSourceTable+".csv")

        cTargetPath:=GetDataPathSplit()
        cTargetPath+=(cSourceTable+"\")

        SplitFileDel(cSourceTable)

        SplitOptions(@nSplitSize)

        aFiles:=fileTools():SplitTXTfile(cSourceFile,cTargetPath,nSplitSize)

        nFiles:=Len(aFiles)
        lSplitFile:=(nFiles>0)

        if ((lSplitFile).and.(ApMsgYesNo("Deseja Consultar os arquivos gerados?",cTools():Accentuation("Aten#1#2o!","ccedil","atilde"))))

            for nFile:=1 to nFiles
                oUFLog:FormatLogEntryTbl(cSourceTable,aFiles[nFile],"FILE")
            next nFile

            cLogFile:=oUFLog:FormatLogFile("\log\html\",cSourceTable)
            cLogFile:=strTran(cLogFile,".log",".html")

            oUFLog:LogAsHtmlFile(cLogFile,cSourceTable)

            SplitPath(cLogFile,@cSPPDrive,@cSPPPath,@cSPPFile,@cSPPExt)
            cHTMLTempFile:=(GetTempPath()+cSPPFile+cSPPExt)

            if (__CopyFile(cLogFile,cHTMLTempFile))
                cBaseURL:=oUFLog:LogGetURLBase()
                cHTML:=MemoRead(cLogFile)
                uf.text.view.TextView():ShowHTML(cHTML,cSourceTable,cHTMLTempFile,cBaseURL)
                cHTML:=""
                fErase(cHTMLTempFile)
            endif

            fErase(cLogFile)

            oUFLog:Clean()

        endif

    end sequence

    FreeObj(@oUFLog)
    FWFreeArray(@aFiles)

return(lSplitFile)

static function SplitFileDel(cSourceTable as character) as logical

    local aFiles as array

    local cTargetPath as character

    local lSplitFileDel as logical

    local nFile as numeric
    local nFiles as numeric

    cTargetPath:=GetDataPathSplit()
    cTargetPath+=(cSourceTable+"\")

    aFiles:=Directory(cTargetPath+cSourceTable+"*.csv")
    nFiles:=Len(aFiles)
    for nFile:=1 To nFiles
        cFile:=cTargetPath+aFiles[nFile][1]
        if (file(cFile))
            fErase(cFile)
        endif
    next nFile

    FWFreeArray(@aFiles)

    aFiles:=Directory(cTargetPath+cSourceTable+"*.csv")
    lSplitFileDel:=Empty(aFiles)
    if ((lSplitFileDel).and.(!FwIsInCallStack("DATASUL2TOTVS.SplitFileADD")))
        ApMsgInfo("Arquivos Excluidos com Sucesso!",cSourceTable)
    endif

    FWFreeArray(@aFiles)

return(lSplitFileDel)

static function SplitFileView(cSourceTable as character) as variant
    local cTargetPath:=GetDataPathSplit() as character
    cTargetPath+=(cSourceTable+"\")
return(fileTools():BrowseFiles(cSourceTable,cTargetPath,cSourceTable+"*.csv",1))

static function ShowDatasulFiles() as variant
    local cDataPath:=GetDataPath() as character
return(fileTools():BrowseFiles("Datasul Files",cDataPath,"*.csv",1))
