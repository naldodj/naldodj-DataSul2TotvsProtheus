#define __NToS

#DEFINE DTS_DBS_NAME 1
#DEFINE DTS_DBS_TYPE 2
#DEFINE DTS_DBS_FLG 3
#DEFINE DTS_DBS_FORMAT 4

#DEFINE DTS_DBS_SIZE 4

#include "totvs.ch"
#include "shell.ch"

#include "dbstruct.ch"

#include "jsonhash.ch"
#include "jsonarray.ch"

static st_lfRACodUnic:=FindFunction("fRACodUnic") as logical
static st_oHMbTransform:=THashMap():New() as object

namespace datasul2totvs

class Protheus
    static method Activate() as logical
end class

static method Activate() class Protheus

    local bSRAMsNewProcess as codeblock
    local bSRBMsNewProcess as codeblock
    local bSRDMsNewProcess as codeblock
    local bSRFMsNewProcess as codeblock
    local bSR3MsNewProcess as codeblock
    local bSR8MsNewProcess as codeblock

    local cGetFileRoot:="\" as character
    local cGetFileMask as character
    local cGetFileTitle as character

    local lActivate as logical
    local lSendDataToServer as logical

    local nGetFileOptions as numeric

    local oDlg as object
    local oMenu as object
    local oFont as object
    local oFWDefSize as object

    local oSRAMSNewProcess as object
    local oSRBMSNewProcess as object
    local oSRDMSNewProcess as object
    local oSRFMSNewProcess as object
    local oSR3MSNewProcess as object
    local oSR8MSNewProcess as object

    if (valType(st_oHMbTransform)=="O")
        st_oHMbTransform:Clean()
    endif

    begin sequence

        lSendDataToServer:=ApMsgNoYes("Sending Data To Server?")
        if (lSendDataToServer)
            MsAguarde({||lSendDataToServer:=sendDataToServer(@cGetFileRoot)},"Sending Data To Server","Wait!")
        elseif (file("\datasul2Protheus\ini\DataSul2Protheus.ini"))
            cGetFileRoot:="SERVIDOR\datasul2protheus\ini\"
        endif

        cGetFileMask:="Arquivo de Configuração | DataSul2Protheus.ini"
        cGetFileTitle:="Arquivo de Configuração DataSul2Protheus.ini"
        nGetFileOptions:=(GETF_LOCALHARD+GETF_NETWORKDRIVE)
        cINIfile:=cGetFile(cGetFileMask,cGetFileTitle,1,cGetFileRoot,.F.,nGetFileOptions,/*[lArvore]*/,/*[lKeepCase]*/)

        lActivate:=file(cINIfile)
        if (!lActivate)
            ApMsgAlert("Configuration file invalid ["+cINIfile+"] or not found","Attention")
            break
        endif

        lActivate:=("datasul2protheus.ini"$lower(cINIfile))
        if (!lActivate)
            ApMsgAlert("Configuration file invalid ["+cINIfile+"] or not found","Attention")
            break
        endif

        MsAguarde({||lActivate:=readIniFile(@cINIfile)},"Loading Settings","Wait")
        if (!lActivate)
            break
        endif

        MsAguarde({||lActivate:=readTableDefinition()},"Loading structure of tables","Wait")
        if (!lActivate)
            break
        endif

        oFWDefSize:=FWDefSize():New(.T.,.T.)//Sem enchoicebar
        oFWDefSize:lLateral:=.F.//Calculo vertical
        oFWDefSize:AddObject("TMENU",100,100,.T.,.T.)//TMENU

        oFWDefSize:Process()

        nTop:=oFWDefSize:aWindSize[1]
        nLeft:=oFWDefSize:aWindSize[2]
        nBottom:=oFWDefSize:aWindSize[3]
        nRight:=oFWDefSize:aWindSize[4]

        oFont:=TFont():New("Courier New",nil,16,nil,.T.)

        bSRAMsNewProcess:={|lEnd|ProcRedefine(oSRAMSNewProcess,@oFont,0,650,650,.T.,.T.),ImportSRA(oSRAMSNewProcess,@lEnd)}
        bSRBMsNewProcess:={|lEnd|ProcRedefine(oSRBMSNewProcess,@oFont,0,650,650,.T.,.T.),importSRB(oSRBMSNewProcess,@lEnd)}
        bSRDMsNewProcess:={|lEnd|ProcRedefine(oSRDMSNewProcess,@oFont,0,650,650,.T.,.T.),importSRD(oSRDMSNewProcess,@lEnd)}
        bSRFMsNewProcess:={|lEnd|ProcRedefine(oSRFMSNewProcess,@oFont,0,650,650,.T.,.T.),ImportSRF(oSRFMSNewProcess,@lEnd)}
        bSR3MsNewProcess:={|lEnd|ProcRedefine(oSR3MSNewProcess,@oFont,0,650,650,.T.,.T.),ImportSR3(oSR3MSNewProcess,@lEnd)}
        bSR8MsNewProcess:={|lEnd|ProcRedefine(oSR8MSNewProcess,@oFont,0,650,650,.T.,.T.),ImportSR8(oSR8MSNewProcess,@lEnd)}

        DEFINE MSDIALOG oDlg TITLE "TOTVS :: DataSul To Protheus" FROM nTop,nLeft TO nBottom,nRight PIXEL OF getWNDDefault()

            MENU oMenu IMAGE "" OF oDlg
                MENUITEM "TOTVS :: DataSul To Protheus"
                MENU
                    MENUITEM "Import SRA :: "+Upper(FWSX2Util():GetX2Name("SRA",.F.)) ACTION (oSRAMSNewProcess:=MsNewProcess():New(bSRAMsNewProcess,"Importing SRA :: "+Upper(FWSX2Util():GetX2Name("SRA",.F.))+" :: ["+DToC(Date())+"]["+Time()+"]","Wait!",.T.),oSRAMSNewProcess:Activate())
                    MENUITEM "Import SRB :: "+Upper(FWSX2Util():GetX2Name("SRB",.F.)) ACTION (oSRBMSNewProcess:=MsNewProcess():New(bSRBMsNewProcess,"Importing SRB :: "+Upper(FWSX2Util():GetX2Name("SRB",.F.))+" :: ["+DToC(Date())+"]["+Time()+"]","Wait!",.T.),oSRBMSNewProcess:Activate())
                    MENUITEM "Import SRD :: "+Upper(FWSX2Util():GetX2Name("SRD",.F.)) ACTION (oSRDMSNewProcess:=MsNewProcess():New(bSRDMsNewProcess,"Importing SRD :: "+Upper(FWSX2Util():GetX2Name("SRD",.F.))+" :: ["+DToC(Date())+"]["+Time()+"]","Wait!",.T.),oSRDMSNewProcess:Activate())
                    MENUITEM "Import SRF :: "+Upper(FWSX2Util():GetX2Name("SRF",.F.)) ACTION (oSRFMSNewProcess:=MsNewProcess():New(bSRFMsNewProcess,"Importing SRF :: "+Upper(FWSX2Util():GetX2Name("SRF",.F.))+" :: ["+DToC(Date())+"]["+Time()+"]","Wait!",.T.),oSRFMSNewProcess:Activate())
                    MENUITEM "Import SR3 :: "+Upper(FWSX2Util():GetX2Name("SR3",.F.)) ACTION (oSR3MSNewProcess:=MsNewProcess():New(bSR3MsNewProcess,"Importing SR3 :: "+Upper(FWSX2Util():GetX2Name("SR3",.F.))+" :: ["+DToC(Date())+"]["+Time()+"]","Wait!",.T.),oSR3MSNewProcess:Activate())
                    MENUITEM "Import SR8 :: "+Upper(FWSX2Util():GetX2Name("SR8",.F.)) ACTION (oSR8MSNewProcess:=MsNewProcess():New(bSR8MsNewProcess,"Importing SR8 :: "+Upper(FWSX2Util():GetX2Name("SR8",.F.))+" :: ["+DToC(Date())+"]["+Time()+"]","Wait!",.T.),oSR8MSNewProcess:Activate())
                ENDMENU
                MENU
                    MENUITEM "Settings" ACTION CFGFile()
                ENDMENU
                MENU
                    MENUITEM "Exit" ACTION oDlg:End()
                ENDMENU
            ENDMENU

            oMenu:align:=CONTROL_ALIGN_LEFT
            oDlg:SetMenu(oMenu)

        ACTIVATE DIALOG oDlg CENTERED

        oFont:=FreeObj(oFont)
        oMenu:=FreeObj(oMenu)
        oDlg:=FreeObj(oDlg)

        oSRAMSNewProcess:=FreeObj(oSRAMSNewProcess)
        oSRBMSNewProcess:=FreeObj(oSRBMSNewProcess)
        oSRDMSNewProcess:=FreeObj(oSRDMSNewProcess)
        oSRFMSNewProcess:=FreeObj(oSRFMSNewProcess)
        oSR3MSNewProcess:=FreeObj(oSR3MSNewProcess)
        oSR8MSNewProcess:=FreeObj(oSR8MSNewProcess)

    end sequence

    cacheData():delSection("datasul2totvsprotheus")

    if (findFunction("RstPosAlias"))
        RstPosAlias()
    endif

    if (valType(st_oHMbTransform)=="O")
        st_oHMbTransform:Clean()
    endif

return(lActivate)

static function readIniFile(cINIfile as character) as logical

    local cRootPath as character

    local cSPPDrive as character
    local cSPPPath as character
    local cSPPFile as character
    local cSPPExt as character

    local lreadIniFile:=.F. as logical

    local oTFIni as object

    begin sequence

        lreadIniFile:=(!empty(cINIfile).and.(File(cINIfile)))
        if (!lreadIniFile)
            ApMsgAlert("Configuration file invalid or not found","Attention")
            break
        endif

        SplitPath(cINIfile,@cSPPDrive,@cSPPPath,@cSPPFile,@cSPPExt)

        cRootPath:=cSPPDrive
        cRootPath+=cSPPPath

        cacheData():Set("datasul2totvsprotheus","cINIfile",cINIfile)
        cacheData():Set("datasul2totvsprotheus","cRootPath",cRootPath)

        oTFIni:=TFIni():New(cINIfile,"#")

        cacheData():Set("datasul2totvsprotheus","readIniFile",oTFIni)

    end sequence

return(lreadIniFile)

static function readTableDefinition() as logical

    local aFieldDef as array
    local aFieldDefTmp as array
    local aFieldsDef:=array(0) as array
    local aTablesImport as array

    local cLine as character
    local cLineUTF8 as character

    local cTable as character
    local cRootPath as character
    local cTablesDefinition as character
    local cFileTablesDefinition as character

    local lTypeReplicate:=.F. as logical
    local lSkipTable:=.F. as logical
    local lreadTableDefinition:=.F. as logical

    local nField as numeric
    local nFields as numeric

    local nft_fRecNo as numeric
    local nft_fHandle as numeric

    local nTypeReplicate as numeric

    local oFT as object
    local oTFIni as object
    local oHMTablesImport as object

    begin sequence

        oTFIni:=cacheData():Get("datasul2totvsprotheus","readIniFile")

        aTablesImport:=aClone(oTFIni:GetAllProperties("TablesImport"))
        lreadTableDefinition:=(!empty(aTablesImport))
        if (!lreadTableDefinition)
            ApMsgAlert("Invalid import tables","Attention")
            break
        endif

        cTablesDefinition:=allTrim(oTFIni:GetPropertyValue("Tables","TablesDefinition",""))
        lreadTableDefinition:=(!empty(cTablesDefinition))
        if (!lreadTableDefinition)
            ApMsgAlert("Invalid TablesDefinition","Attention")
            break
        endif

        cRootPath:=cacheData():Get("datasul2totvsprotheus","cRootPath")
        cFileTablesDefinition:=(cRootPath+".."+cTablesDefinition)
        lreadTableDefinition:=file(cFileTablesDefinition)
        if (!lreadTableDefinition)
            ApMsgAlert("File ("+cFileTablesDefinition+") with the definitions of the tables not found","Attention")
            break
        endif

        oFT:=uft():New()

        nft_fHandle:=oFT:ft_fUse(cFileTablesDefinition)
        lreadTableDefinition:=(nft_fHandle>=0)
        if (!lreadTableDefinition)
            ApMsgAlert("Could not open the file: "+cFileTablesDefinition,"Attention")
            break
        endif

        oHMTablesImport:=aToHM(aTablesImport,2)

        oFT:ft_fGoTop()

        while (!oFT:ft_fEof())
            cLine:=oFT:ft_fReadLN()
            begin sequence
                if (empty(cLine))
                    break
                endif
                cTable:=""
                if ("Table:"==Left(cLine,6))
                    cTable:=strTran(cLine,"Table:","")
                    cTable:=allTrim(cTable)
                    lSkipTable:=(!oHMTablesImport:Get(cTable))
                    if (lSkipTable)
                        break
                    else
                        oFT:ft_fDelete()
                        oFT:ft_fSkip()
                    endif
                    aSize(aFieldsDef,0)
                    while (!oFT:ft_fEof())
                        cLine:=oFT:ft_fReadLN()
                        if (empty(cLine).or.("Field Name"==Left(cLine,10)).or.("-"==Left(cLine,1)))
                            oFT:ft_fDelete()
                            oFT:ft_fSkip()
                            loop
                        endif
                        if ("Table:"==Left(cLine,6))
                            cacheData():Set("datasul2totvsprotheus",cTable,aClone(aFieldsDef))
                            aSize(aFieldsDef,0)
                            nft_fRecNo:=oFT:ft_fRecNo()
                            oFT:ft_fGoTo(nft_fRecNo-1)
                            break
                        endif
                        cLine:=cTools():StrReplace(cLine,{"  "," "})
                        cLineUTF8:=DecodeUTF8(cLine)
                        if (empty(cLineUTF8))
                            cLine:=OemToAnsi(cLine)
                        endif
                        cLineUTF8:=""
                        aFieldDef:=strTokArr2(cLine," ")
                        cLine:=""
                        if (len(aFieldDef)!=DTS_DBS_SIZE)
                            aFieldDefTmp:=array(DTS_DBS_SIZE)
                            aFieldDefTmp[DTS_DBS_NAME]:=aFieldDef[DTS_DBS_NAME]
                            aFieldDefTmp[DTS_DBS_TYPE]:=aFieldDef[DTS_DBS_TYPE]
                            aFieldDefTmp[DTS_DBS_FLG]:=""//DTS_DBS_FLG
                            aFieldDefTmp[DTS_DBS_FORMAT]:=aFieldDef[DTS_DBS_FLG]
                            aFieldDef:=aClone(aFieldDefTmp)
                            FWFreeArray(@aFieldDefTmp)
                        endif
                        nTypeReplicate:=AT("[",aFieldDef[DTS_DBS_TYPE])
                        lTypeReplicate:=(nTypeReplicate>0)
                        if (lTypeReplicate)
                            nFields:=val(subStr(aFieldDef[DTS_DBS_TYPE],(nTypeReplicate+1),(AT("]",aFieldDef[DTS_DBS_TYPE])-1)))
                            aAdd(aFieldsDef,aClone(aFieldDef))
                            if (nFields>1)
                                aFieldDefTmp:=aClone(aFieldDef)
                                cacheData():Set("datasul2totvsprotheus",cTable+"_TypeReplicate",lTypeReplicate)
                                cacheData():Set("datasul2totvsprotheus",aFieldDef[DTS_DBS_NAME]+"_TypeReplicate",nFields)
                                for nField:=2 to nFields
                                    aFieldDef[DTS_DBS_NAME]:=(aFieldDefTmp[DTS_DBS_NAME]+cTools():NToS(nField))
                                    aAdd(aFieldsDef,aClone(aFieldDef))
                                next nField
                                FWFreeArray(@aFieldDefTmp)
                            endif
                        else
                            aAdd(aFieldsDef,aClone(aFieldDef))
                        endif
                        FWFreeArray(@aFieldDef)
                        oFT:ft_fDelete()
                        oFT:ft_fSkip()
                    end while
                    cacheData():Set("datasul2totvsprotheus",cTable,aClone(aFieldsDef))
                    aSize(aFieldsDef,0)
                elseif (lSkipTable)
                    break
                endif
            end sequence
            oFT:ft_fDelete()
            oFT:ft_fSkip()
        end while

        oFT:ft_fUse()
        oFT:=FreeObj(oFT)

    end sequence

    FWFreeArray(@aFieldsDef)

    if (valtype(oHMTablesImport)=="O")
        oHMTablesImport:Clean()
        oHMTablesImport:=FreeObj(oHMTablesImport)
    endif

    if (valtype(aTablesImport)=="A")
        FWFreeArray(@aTablesImport)
    endif

return(lreadTableDefinition)

static function getTargetFieldValue(lHasError as logical,oTFIni as object,aLine as array,cTargetField as character,aTargetField as array,aSourceFieldsDef as array,oHMSourceFieldsDef as object,cType as character) as variant

    local aValueField as array
    local aSourceField as array

    local bTransform as codeblock

    local cTransform as character
    local cSourceField as character

    local lSourceTransform as logical

    local nLineSize:=Len(aLine) as numeric
    local nSourceField as numeric
    local nSourceFields as numeric
    local nSourceFieldAT as numeric

    local xValue as variant

    begin sequence

        cSourceField:=aTargetField[2]
        lSourceTransform:=("@"==Left(cSourceField,1))
        if (lSourceTransform)
            cSourceField:=subStr(cSourceField,2)
        endif
        aSourceField:=strToKArr2(cSourceField,"+")
        nSourceFields:=len(aSourceField)
        aValueField:=Array(nSourceFields,2)
        for nSourceField:=1 to nSourceFields
            cSourceField:=aSourceField[nSourceField]
            if (!oHMSourceFieldsDef:Get(cSourceField,@cType))
                loop
            endif
            if (!oHMSourceFieldsDef:Get(cSourceField+"_AT",@nSourceFieldAT))
                loop
            endif
            lHasError:=(nSourceFieldAT>nLineSize)
            if (lHasError)
                break
            endif
            aValueField[nSourceField][1]:=NormalizeData(@lHasError,aLine[nSourceFieldAT],@cType,@cSourceField,@lSourceTransform,@st_oHMbTransform,@oTFIni)
            if (lHasError)
                break
            endif
            aValueField[nSourceField][2]:=cType
            if (cType=="char")
                xValue:=""
            endif
        next nSourceField

        for nSourceField:=1 to nSourceFields
            if (aValueField[nSourceField][2]=="char")
                xValue+=aValueField[nSourceField][1]
            else
                xValue:=aValueField[nSourceField][1]
            endif
        next nSourceField

        if (!st_oHMbTransform:Get(cTargetField,@bTransform))
            cTransform:=allTrim(oTFIni:GetPropertyValue(cTargetField,"Transform",""))
            if (cTransform=="FindInTable")
                cTransform:=allTrim(oTFIni:GetPropertyValue(cTargetField,cTransform,""))
                bTransform:=&(cTransform)
            elseif (!empty(cTransform))
                bTransform:=&(cTransform)
            endif
            st_oHMbTransform:Set(cTargetField,bTransform)
        endif

        if (valtype(bTransform)=="B")
            lHasError:=(!EvalBlock():EvalBlock({||xValue:=Eval(bTransform,xValue,@oTFIni,@cType)},nil,.F.,nil,nil))
        endif

    end sequence

    if (!empty(aValueField))
        FWFreeArray(@aValueField)
    endif

    if (!empty(aValueField))
        FwFreeArray(@aSourceField)
    endif

return(xValue)

static function NormalizeData(lHasError as logical,xValue as variant,cType as character,cSourceField as character,lSourceTransform as logical,st_oHMbTransform as object,oTFIni as object) as variant

    local bTransform as codeblock

    local cTransform as character

    if (lSourceTransform)
        if (!st_oHMbTransform:Get(cSourceField,@bTransform))
            cTransform:=allTrim(oTFIni:GetPropertyValue(cSourceField,"Transform",""))
            if (cTransform=="FindInTable")
                cTransform:=allTrim(oTFIni:GetPropertyValue(cSourceField,cTransform,""))
                bTransform:=&(cTransform)
            elseif (!empty(cTransform))
                bTransform:=&(cTransform)
            endif
            st_oHMbTransform:Set(cSourceField,bTransform)
        endif
        if (valtype(bTransform)=="B")
            lHasError:=(!EvalBlock():EvalBlock({||xValue:=Eval(bTransform,xValue,oTFIni,@cType)},nil,.F.,nil,nil))
            if (!lHasError)
                xValue:=NormalizeData(@lHasError,xValue,@cType,nil,.F.,nil,nil)
            endif
        endif
    else
        if (valType(xValue)=="C")
            if (cType=="char")
                xValue:=strTran(xValue,'"',"")
            elseif (cType=="inte")
                xValue:=Int(val(xValue))
            elseif ("deci"$cType)
                if (","$xValue)
                    xValue:=strTran(xValue,",",".")
                endif
                xValue:=val(xValue)
            elseif (cType=="date")
                xValue:=CToD(xValue)
            elseif (cType=="logi")
                xValue:=(Left(lower(xValue),1)$"sty1")
            endif
        endif
    endif

return(xValue)

static function FindInTable(oTFIni as object,cTable as character,xValue as variant,lTableInFile as logical)

    local cType as character

    local cINIfile as character
    local cRootPath as character

    local oTFIniTable as object

    local xTmp as variant

    cType:=valType(xValue)
    if (cType=="N")
        xValue:=ctools():NToS(xValue)
    elseif (cType!="C")
        xValue:=cValToChar(xValue)
    endif

    if (oTFIni:ExistSection(cTable))
        if (oTFIni:GetATProperty(cTable,"FindInTableFile")>0)
            dfv():Default(@lTableInFile,.F.)
            if (lTableInFile)
                oTFIniTable:=cacheData():Get("datasul2totvsprotheus",cTable,nil)
                if (oTFIniTable==nil)
                    cRootPath:=cacheData():Get("datasul2totvsprotheus","cRootPath")
                    cINIfile:=cRootPath
                    cINIfile+=oTFIni:GetPropertyValue(cTable,"FindInTableFile","")
                    oTFIniTable:=TFIni():New(cINIfile,"#")
                    cacheData():Set("datasul2totvsprotheus",cTable,oTFIniTable)
                endif
                xTmp:=oTFIniTable:GetPropertyValue(cTable,xValue,"")
                if ((empty(xTmp)).and.((oTFIniTable:GetATProperty(cTable,"__DFV__")>0)))
                    xTmp:=oTFIniTable:GetPropertyValue(cTable,"__DFV__","")
                endif
                xValue:=xTmp
            else
                oTFIniTable:=cacheData():Get("datasul2totvsprotheus",cTable,nil)
                if (oTFIniTable==nil)
                    cRootPath:=cacheData():Get("datasul2totvsprotheus","cRootPath")
                    cINIfile:=cRootPath
                    cINIfile+=oTFIni:GetPropertyValue(cTable,"FindInTableFile","")
                    oTFIniTable:=TFIni():New(cINIfile,"#")
                    cacheData():Set("datasul2totvsprotheus",cTable,oTFIniTable)
                endif
                xValue:=FindInTable(oTFIniTable,cTable,xValue)
            endif
        elseif ((oTFIni:GetATProperty(cTable,xValue)>0))
            xValue:=oTFIni:GetPropertyValue(cTable,xValue,"")
        elseif ((oTFIni:GetATProperty(cTable,"__DFV__")>0))
            xValue:=oTFIni:GetPropertyValue(cTable,"__DFV__","")
        endif
    endif

return(xValue)

static function getR8Seq() as character

    static c_stHMSR8SeqKey as character

    local cStack:="DATASUL2TOTVS.IMPORTSR8" as character

    local cR8MAT as character
    local cR8SEQ:="" as character
    local cR8TIPO as character
    local cR8FILIAL as character
    local cR8DATAINI as character
    local cR8TIPOAFA as character

    local cHMSR8SeqKey:="" as character

    local cTmpAlias as character

    local dR8DATAINI as date

    begin sequence

        if (type("cPVTSR8Alias")!="C")
            _SetNamedPRVT("cPVTSR8Alias",cacheData():Get("datasul2totvsprotheus","importSR8Alias","__NOALIAS__"),cStack)
        endif

        cTmpAlias:=cPVTSR8Alias
        if (select(cTmpAlias)==0)
            break
        endif

        cR8FILIAL:=(cTmpAlias)->R8_FILIAL
        cR8MAT:=(cTmpAlias)->R8_MAT
        dR8DATAINI:=(cTmpAlias)->R8_DATAINI
        cR8TIPO:=(cTmpAlias)->R8_TIPO
        cR8TIPOAFA:=(cTmpAlias)->R8_TIPOAFA

        cR8DATAINI:=DToS(dR8DATAINI)

        cHMSR8SeqKey:=&("cEmpAnt")
        cHMSR8SeqKey+=cR8FILIAL
        cHMSR8SeqKey+=cR8MAT

        if (type("oPVTHMSR8Seq")!="O")
            _SetNamedPRVT("oPVTHMSR8Seq",THashMap():New(),cStack)
        else
            if (c_stHMSR8SeqKey!=cHMSR8SeqKey)
                c_stHMSR8SeqKey:=cHMSR8SeqKey
                oPVTHMSR8Seq:Clean()
            endif
        endif

        cHMSR8SeqKey+=cR8DATAINI
        cHMSR8SeqKey+=cR8TIPO
        cHMSR8SeqKey+=cR8TIPOAFA

        if (!oPVTHMSR8Seq:Get(cHMSR8SeqKey,@cR8SEQ)).or.(Empty(cR8SEQ))
            if (type("nPVTSR8Seq")!="N")
                _SetNamedPRVT("nPVTSR8Seq",GetSx3Cache("R8_SEQ","X3_TAMANHO"),cStack)
                cR8SEQ:=Replicate("0",nPVTSR8Seq)
                _SetNamedPRVT("cPVTR8SEQ",cR8SEQ,cStack)
            endif
            cR8SEQ:=cPVTR8SEQ
        endif

        cR8SEQ:=__Soma1(cR8SEQ)

        oPVTHMSR8Seq:Set(cHMSR8SeqKey,cR8SEQ)

    end sequence

return(cR8SEQ)

static function ProcRedefine(oProcess as object,oFont as object,nLeft as numeric,nWidth as numeric,nCTLFLeft as numeric,lODlgF as logical,lODlgW as logical) as logical
    local lProcRedefine as logical
    lProcRedefine:=MsProcess():ProcRedefine(@oProcess,@oFont,@nLeft,@nWidth,@nCTLFLeft,@lODlgF,@lODlgW)
    return(lProcRedefine)

static function SetFilAnt(cFil)
    local cSvFilAnt:=&("cFilAnt") as character
    if (valType("cFilAnt")=="C")
        cSvFilAnt:=&("cFilAnt")
        if (cFil!=cSvFilAnt)
            &("cFilAnt"):=cFil
        endif
        FWSM0Util():setSM0PositionBycFilAnt()
    endif
return(cSvFilAnt)

static procedure CFGFile()

    local cINIFile as character
    local cMemoEdit as character
    local cGetFileRoot as character
    local cGetFileMask as character
    local cGetFileTitle as character

    local lHasINIFile as logical

    local nGetFileOptions as numeric

    begin sequence

        cGetFileRoot:=cacheData():Get("datasul2totvsprotheus","cRootPath")
        cGetFileMask:="Arquivo de Configuração | *.ini"
        cGetFileTitle:="Arquivo de Configuração *.ini"
        nGetFileOptions:=(GETF_LOCALHARD+GETF_NETWORKDRIVE)
        cINIfile:=cGetFile(cGetFileMask,cGetFileTitle,1,cGetFileRoot,.F.,nGetFileOptions,/*[lArvore]*/,/*[lKeepCase]*/)

        lHasINIFile:=File(cINIfile)
        if (!lHasINIFile)
            break
        endif

        cMemoEdit:=ReadMemoCFGFile(cINIfile)

        if (EdtCFGFile(@cINIfile,@cMemoEdit))
            if ("datasul2protheus.ini"$lower(cINIfile))
                MsAguarde({||readIniFile(@cINIfile)},"Loading Settings","Wait")
                if (valType(st_oHMbTransform)=="O")
                    st_oHMbTransform:Clean()
                endif
                MsAguarde({||readTableDefinition()},"Loading structure of tables","Wait")
            else
                cINIfile:=cacheData():Get("datasul2totvsprotheus","cINIfile")
                cacheData():delSection("datasul2totvsprotheus")
                MsAguarde({||readIniFile(@cINIfile)},"Loading Settings","Wait")
                if (valType(st_oHMbTransform)=="O")
                    st_oHMbTransform:Clean()
                endif
                MsAguarde({||readTableDefinition()},"Loading structure of tables","Wait")
            endif
        endif

    end sequence

    return

static function EdtCFGFile(cINIfile as character,cMemoEdit as character) as logical

    local aButtons as array
    local aAdvSize as array
    local aObjSize as array
    local aObjCoords as array
    local aInfoAdvSize as array

    local bSet15 as codeblock
    local bSet24 as codeblock
    local bNotepadCFGFile as codeblock
    local bRestoreCFGFile as codeblock

    local cTitle as character
    local cSVMemoEdit as character

    local lOk as logical

    local nDlgWidth as numeric

    local oDlg as object
    local oFont as object
    local oPanel as object
    local oMemoEdit as object

    dfv():Default(@cMemoEdit,"")

    cSVMemoEdit:=cMemoEdit

    begin sequence

        aAdvSize:=MsAdvSize()
        aInfoAdvSize:={aAdvSize[1],aAdvSize[2],aAdvSize[3],aAdvSize[4],0,0}
        aObjCoords:=array(0)
        aAdd(aObjCoords,{0,0,.T.,.T.})
        aObjSize:=MsObjSize(aInfoAdvSize,aObjCoords)

        cTitle:="ARQUIVO CONFIGURACAO "
        cTitle+=" :: "
        cTitle+=cINIfile

        DEFINE FONT oFont NAME "Courier New" SIZE 0,-11 BOLD
        DEFINE MSDIALOG oDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL

            nDlgWidth:=__DlgWidth(oDlg)

            oPanel:=tPanel():New(0,0,"",oDlg,nil,nil,nil,nil,nil,nDlgWidth,nDlgWidth)

            @(aObjSize[1][1]+5),(aObjSize[1][2]+5) GET oMemoEdit VAR cMemoEdit MEMO SIZE ((aObjSize[1][4]/100)*99),((aObjSize[1][3]/100)*88) FONT oFont CENTERED DESIGN OF oPanel PIXEL WHEN (.T.)

            oMemoEdit:lReadOnly:=.F.
            oMemoEdit:EnableVScroll(.T.)
            oMemoEdit:EnableHScroll(.T.)

            oDlg:lEscClose:=.F.

            bSet15:={||lOk:=ChgCFGFile(@cINIfile,@cMemoEdit,@cSVMemoEdit),if(lOk,oDlg:End(),lOK)}
            bSet24:={||lOK:=.F.,oDlg:End()}

            aButtons:=array(0)
            bNotepadCFGFile:={||MsProcess():MsAguarde({||NotepadCFGFile(cINIfile)},"Abrindo no NotepadCFGFile","Aguarde...")}
            aAdd(aButtons,{"NotepadCFGFile",bNotepadCFGFile,OemToAnsi("Abir no NotepadCFGFile"),OemtoAnsi("Abir no NotepadCFGFile")})
            bRestoreCFGFile:={||MsProcess():MsAguarde({||RestoreCFGFile(cINIfile,@cMemoEdit,@oMemoEdit,@cSVMemoEdit)},"Restaurando Versao Anterior","Aguarde...")}
            aAdd(aButtons,{"RestoreCFGFile",bRestoreCFGFile,OemToAnsi("Restaurar Versao Anterior"),OemtoAnsi("Restaurar Versao Anterior")})

        ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,bSet15,bSet24,nil,@aButtons)

    end sequence

    return(lOk)

static function ChgCFGFile(cINIfile as character,cMemoEdit as character,cSVMemoEdit as character) as logical

    local cMsg as character
    local cTitle as character

    local cSPDriver as character
    local cSPPath as character
    local cSPFileName as character
    local cSPFileExt as character

    local cFWWSBKP as character

    local lFilial as logical
    local lEmpresa as logical
    local lChgCFGFile as logical

    local nAttemps as numeric

    lFilial:=(type("cFilAnt")=="C")
    lEmpresa:=(type("cEmpAnt")=="C")

    begin sequence

        lChgCFGFile:=(cMemoEdit==cSVMemoEdit)
        if (lChgCFGFile)
            break
        endif

        cSPDriver:=""
        cSPPath:=""
        cSPFileName:=""
        cSPFileExt:=""

        SplitPath(cINIfile,@cSPDriver,@cSPPath,@cSPFileName,@cSPFileExt)

        cMsg:="Deseja Gravar as Alteracoes?"

        cTitle:="ARQUIVO CONFIGURACAO  :: "
        cTitle+=cSPFileName

        lChgCFGFile:=ApMsgYesNo(cMsg,cTitle)
        if (!lChgCFGFile)
            break
        endif

        cFWWSBKP:=cSPDriver
        cFWWSBKP+=cSPPath
        cFWWSBKP+=cSPFileName
        cFWWSBKP+=cSPFileExt
        cFWWSBKP+="-"
        cFWWSBKP+=DToS(Date())
        cFWWSBKP+="-"
        cFWWSBKP+=strTran(Time(),":","-")
        cFWWSBKP+="-"
        cFWWSBKP+=strZero(ranDomize(1,999),3)

        nAttemps:=0

        cMsg:="O arquivo "
        cMsg+=cINIfile
        cMsg+=" encontra-se em uso deseja tentar novamente?"

        while (!LockByName(cSPFileName,lEmpresa,lFilial,.T.))
            if (nAttemps++>10)
                nAttemps:=0
                if (!MsgYesNo(cMsg,cTitle))
                    lChgCFGFile:=.F.
                    cMsg:="O arquivo "
                    cMsg+=cINIfile
                    cMsg+=" encontra-se em uso e nao podera ser salvo."
                    ApMsgAlert(cMsg,cTitle)
                    break
                endif
            endif
            sleep(300)
        end while

        nAttemps:=0

        while (file(cINIfile))
            if (fRename(cINIfile,cFWWSBKP))
                exit
            endif
            if (nAttemps++>10)
                nAttemps:=0
                if (!MsgYesNo(cMsg,cTitle))
                    UnlockByName(cSPFileName,lEmpresa,lFilial,.T.)
                    lChgCFGFile:=.F.
                    cMsg:="Problema na gravacao do arquivo : "
                    cMsg+=cINIfile
                    ApMsgAlert(cMsg,cTitle)
                    break
                endif
            endif
            sleep(300)
        end while

        nAttemps:=0

        cMsg:="Problema na gravacao do arquivo : "
        cMsg+=cINIfile
        cMsg+=" Deseja tentar novamente?"

        while (!(lChgCFGFile:=MemoWrite(cINIfile,cMemoEdit)))
            if (nAttemps++>10)
                nAttemps:=0
                if (!MsgYesNo(cMsg,cTitle))
                    exit
                endif
            endif
            sleep(300)
        end while

        UnlockByName(cSPFileName,lEmpresa,lFilial,.T.)

        if (!lChgCFGFile)
            cMsg:="Problema na gravacao do arquivo : "
            cMsg+=cINIfile
            ApMsgAlert(cMsg,cTitle)
            break
        endif

        cMsg:="Arquivo "
        cMsg+=cINIfile
        cMsg+=" salvo com sucesso."
        ApMsgInfo(cMsg,cTitle)

    end sequence

    return(lChgCFGFile)

static procedure NotepadCFGFile(cINIfile as character)

    local cSPDriver as character
    local cSPPath as character
    local cSPFileName as character
    local cSPFileExt as character

    local cTempPath as character
    local cTempFile as character

    cSPDriver:=""
    cSPPath:=""
    cSPFileName:=""
    cSPFileExt:=""

    SplitPath(cINIfile,@cSPDriver,@cSPPath,@cSPFileName,@cSPFileExt)

    cTempPath:=getTempPath()
    if (!(right(cTempPath,1)=="\"))
        cTempPath+="\"
    endif

    cTempFile:=cTempPath
    cTempFile+=cSPFileName
    cTempFile+=cSPFileExt

    if (__CopyFile(cINIfile,cTempFile))
        ShellExecute("open",cTempFile,"","",SW_SHOW)
    endif

    return

static function RestoreCFGFile(cINIfile as character,cMemoEdit as character,oMemoEdit as object,cSVMemoEdit as character) as logical

    local cMask as character
    local cTitle as character
    local cFileRead as character
    local cDirectory as character

    local cSPDriver as character
    local cSPPath as character
    local cSPFileName as character
    local cSPFileExt as character

    local lRestoreCFGFile as logical

    local nOptions as numeric

    begin sequence

        cSPDriver:=""
        cSPPath:=""
        cSPFileName:=""
        cSPFileExt:=""

        SplitPath(cINIfile,@cSPDriver,@cSPPath,@cSPFileName,@cSPFileExt)

        cMask:="Arquivos de Configuracao|"+cSPFileName+"*"
        cTitle:="Restaurar arquivo de Configuracao"
        cDirectory:=cSPDriver
        cDirectory+=cSPPath
        cDirectory:=StrTran(cSPPath,"/","\")
        nOptions:=GETF_NOCHANGEDIR

        cFileRead:=cGetFile(cMask,cTitle,1,cDirectory,.F.,nOptions,/*[lArvore]*/,/*[lKeepCase]*/)

        if (empty(cFileRead))
            break
        endif

        cFileRead:=(cDirectory+cFileRead)
        cFileRead:=StrTran(cFileRead,"\\","\")

        if (!file(cFileRead))
            break
        endif

        cSvMemoEdit:=cMemoEdit
        cMemoEdit:=ReadMemoCFGFile(cFileRead)

        lRestoreCFGFile:=ChgCFGFile(@cINIfile,@cMemoEdit,@cSVMemoEdit)

        if (!lRestoreCFGFile)
            cMemoEdit:=cSvMemoEdit
            break
        endif

        cSvMemoEdit:=cMemoEdit

        oMemoEdit:Refresh()

    end sequence

    return(lRestoreCFGFile)

static function ReadMemoCFGFile(cFile) as character
    local cMemoRead as character
    cMemoRead:=cTools():ReadMemo(cFile)
    return(cMemoRead)

static function sendDataToServer(cGetFileRoot as character) as logical

    local aZipFiles:=array(0) as array

    local aFiles as array
    local aDirectories as array

    local cFile as character
    local cZipFile as character
    local cDirectory as character
    local cGetFileMask:="" as character
    local cGetFileTitle as character
    local cZipFileServer as character
    local cLowerDirectory as character
    local cDirectoryClient as character
    local cDirectoryServer as character

    local cSPPDrive as character
    local cSPPPath as character
    local cSPPFile as character
    local cSPPExt as character

    local lSendDataToServer as logical

    local nFile as numeric
    local nFiles as numeric
    local nDirectory as numeric
    local nDirectories as numeric
    local nGetFileOptions as numeric

    cGetFileTitle:="Diretorio de Configuração DataSul2Protheus.ini"
    nGetFileOptions:=(GETF_LOCALHARD+GETF_NETWORKDRIVE+GETF_RETDIRECTORY)
    cDirectoryClient:=cGetFile(cGetFileMask,cGetFileTitle,1,".\",.F.,nGetFileOptions,/*[lArvore]*/,/*[lKeepCase]*/)

    begin sequence

        lSendDataToServer:=((lIsDir(cDirectoryClient)).and.("datasul2protheus"$StrTran(lower(cDirectoryClient),"totvs","")))
        if (!lSendDataToServer)
            if (ApMsgYesNo("Invalid directory ["+cDirectoryClient+"]. Want to try again?"))
                lSendDataToServer:=sendDataToServer(@cGetFileRoot)
            elseif (file("\datasul2Protheus\ini\DataSul2Protheus.ini"))
                cGetFileRoot:="SERVIDOR\datasul2protheus\ini\"
            endif
            break
        elseif (file("\datasul2Protheus\ini\DataSul2Protheus.ini"))
            cGetFileRoot:="SERVIDOR\datasul2protheus\ini\"
        endif

        cDirectoryServer:="\datasul2Protheus\"
        DirTools():MakeFileDir(cDirectoryServer)
        lSendDataToServer:=lIsDir(cDirectoryServer)
        if (!lSendDataToServer)
            ApMsgAlert("Invalid directory ["+cDirectoryServer+"]")
            break
        endif

        aDirectories:=Directory(cDirectoryClient+"*.*","D")
        nDirectories:=Len(aDirectories)

        lSendDataToServer:=(nDirectories!=0)
        if (!lSendDataToServer)
            ApMsgAlert("No valid directory information found")
            break
        endif

        for nDirectory:=1 to nDirectories
            if (aDirectories[nDirectory][5]!="D")
                loop
            endif
            cDirectory:=cDirectoryClient+aDirectories[nDirectory][1]
            if (right(cDirectory,1)==".")
                loop
            endif
            cLowerDirectory:=lower(cDirectory)
            if (("7z"$cLowerDirectory).or.("src"$cLowerDirectory).or.(".gitignore"$cLowerDirectory).or.(".vscode"$cLowerDirectory))
                loop
            endif
            if (Right(cDirectory,1)!="\")
                cDirectory+="\"
            endif
            aFiles:=Directory(cDirectory+"*.*")
            nFiles:=Len(aFiles)
            for nFile:=1 To nFiles
                cFile:=cDirectory+aFiles[nFile][1]
                aAdd(aZipFiles,cFile)
                MsProcTxt(aFiles[nFile][1])
            next nFile
        next nDirectory

        cZipFile:=(getTempPath()+criatrab(nil,.F.)+".zip")
        MsProcTxt("ZipFile. Wait...")
        lSendDataToServer:=(FZip(cZipFile,aZipFiles,cDirectoryClient,/*,[cSenha]*/)==0)
        if (!lSendDataToServer)
            ApMsgAlert("Problem zipping ["+cZipFile+"] file")
            break
        endif

        SplitPath(cZipFile,@cSPPDrive,@cSPPPath,@cSPPFile,@cSPPExt)

        cZipFileServer:=cDirectoryServer
        cZipFileServer+=cSPPFile
        cZipFileServer+=cSPPExt

        MsProcTxt("Wait...")
        lSendDataToServer:=__CopyFile(cZipFile,cZipFileServer)
        if (!lSendDataToServer)
            ApMsgAlert("Problem copying ["+cZipFile+"] file to server")
            break
        endif

        MsProcTxt("UnZipFile. Wait...")
        lSendDataToServer:=(FUnzip(cZipFileServer,cDirectoryServer,/*[cSenha]*/)==0)
        if (!lSendDataToServer)
            ApMsgAlert("Problem unzipping the test ["+cZipFile+"] on the server")
            break
        endif

        cGetFileRoot:="SERVIDOR"+cDirectoryServer

        ApMsgInfo("Files uploaded to the server successfully. Directory ["+cGetFileRoot+"]")

        cGetFileRoot+="ini\"

    end sequence

    if (!empty(aFiles))
        FWFreeArray(@aFiles)
    endif

    if (!empty(aZipFiles))
        FWFreeArray(@aZipFiles)
    endif

    if (!empty(aDirectories))
        FWFreeArray(@aDirectories)
    endif

    if (!empty(cZipFile)).and.(file(cZipFile))
        fErase(cZipFile)
    endif

    if ((!empty(cZipFileServer)).and.(file(cZipFileServer)))
        fErase(cZipFileServer)
    endif

return(lSendDataToServer)

static function ImportData(oMsNewProcess as object,lEnd as logical,aLogDet as array,aLogTitle as array,cAlias as character,cIndexKey as character,cTableImport as character,aAddIndex as array) as logical

    local aLog:=array(0) as array

    local aLine as array
    local aField as array

    local aFieldsDef:=array(0) as array

    local aTargetStruct:=(cAlias)->(dbStruct()) as array
    local aTargetFieldsDef as array
    local aTargetFieldsDefReplicate as array

    local aUpdateTableFields as array
    local aUpdateTableSource as array

    local cError as character
    local cField as character
    local cLineUTF8 as character

    local cTmpAlias:=getNextAlias() as character

    local cType as character

    local cLine as character
    local cRootPath as character
    local cDataPath as character
    local cSourceFile as character
    local cSourceTable as character

    local cSVFilAnt:=&("cFilAnt") as character

    local cRecCount as character

    local cIndexID as character
    local cFieldFilial as character
    local cAliasxFilial as character

    local cIncProc as character
    local cTimeRemaining as character

    local cSeekTable as character
    local cSeekIndexKey as character
    local cSeekTableIndex as character
    local cAllSeekIndexKey as character
    local cUpdateTableFields as character
    local cUpdateTableSource as character

    local lFound as logical
    local lAddNew as logical
    local lAppend as logical
    local ldbPack:=.F. as logical
    local ldbCommit as logical
    local lHasError:=.F. as logical
    local lChkFilial as logical
    local lChkEncode as logical
    local lSeekTable as logical
    local lImportData as logical
    local lRecCountStep as logical
    local lTypeReplicate:=.F. as logical
    local lAppendIfNotExist as logical
    local lUpdateTableFields:=.F. as logical

    local nField as numeric
    local nFields as numeric

    local nReplicate as numeric
    local nReplicates:=0 as numeric

    local nRecProc:=0 as numeric
    local nRecCount as numeric
    local nRecCountStep as numeric
    local nCommitBuffer as numeric
    local nTargetFieldPos as numeric

    local nIndexKey:=retOrder(cAlias,cIndexKey,.T.) as numeric
    local nSeekTableIndex as numeric
    local nUpdateTableSource as numeric

    local nIncProcStep as numeric

    local nft_fRecNo as numeric
    local nft_fHandle as numeric

    local nMLLine as numeric
    local nMLCount as numeric
    local nMLCountSize:=220 as numeric

    local oFT as object
    local oTFIni as object
    local oProgress as object
    local oHMTargetStruct as object
    local oTimeRemaining as object
    local oFWTemporaryTable as object
    local oHMSourceFieldsDef as object

    begin sequence

        if (nIndexKey==0)
            ApMsgAlert("Unlocalized "+cAlias+" table search index ("+cIndexKey+")")
            break
        endif

        oTFIni:=cacheData():Get("datasul2totvsprotheus","readIniFile")

        cSourceTable:=allTrim(oTFIni:GetPropertyValue("TablesImport",cTableImport,""))
        lImportData:=(!empty(cSourceTable))
        if (!lImportData)
            ApMsgAlert("There is no setting for the SRA table","Attention")
            break
        endif

        cDataPath:=allTrim(oTFIni:GetPropertyValue("Tables","TablesData",""))
        lImportData:=(!empty(cDataPath))
        if (!lImportData)
            ApMsgAlert("Invalida Data Path ("+cDataPath+")","Attention")
            break
        endif

        cRootPath:=cacheData():Get("datasul2totvsprotheus","cRootPath")
        cSourceFile:=(cRootPath+".."+cDataPath+cSourceTable+".csv")
        lImportData:=file(cSourceFile)
        if (!lImportData)
            ApMsgAlert("File ("+cSourceFile+") not found","Attention")
            break
        endif

        aFieldsDef:=aClone(cacheData():Get("datasul2totvsprotheus",cSourceTable,aFieldsDef))
        lImportData:=(!empty(aFieldsDef))
        if (!lImportData)
            ApMsgAlert("Field definitions for the "+cSourceTable+" table not found","Attention")
            break
        endif

        lTypeReplicate:=cacheData():Get("datasul2totvsprotheus",cSourceTable+"_TypeReplicate",lTypeReplicate)
        if (lTypeReplicate)
            lTypeReplicate:=(Lower(allTrim(oTFIni:GetPropertyValue(cSourceTable,"TypeReplicate","")))=="row")
        endif

        oHMSourceFieldsDef:=THashMap():New()
        nFields:=Len(aFieldsDef)
        for nField:=1 to nFields
            oHMSourceFieldsDef:Set(aFieldsDef[nField][DTS_DBS_NAME],aFieldsDef[nField][DTS_DBS_TYPE])
            oHMSourceFieldsDef:Set(aFieldsDef[nField][DTS_DBS_NAME]+"_AT",nField)
        next nField

        aTargetFieldsDef:=aClone(oTFIni:GetAllProperties(cSourceTable))
        lImportData:=(!empty(aFieldsDef))
        if (!lImportData)
            ApMsgAlert("Field definitions for the "+cTableImport+" table not found","Attention")
            break
        endif

        nFields:=Len(aTargetStruct)
        for nField:=1 to nFields
            aAdd(aTargetStruct[nField],nField)
        next nField
        oHMTargetStruct:=aToHM(aTargetStruct,DBS_NAME)

        nFields:=Len(aTargetFieldsDef)
        for nField:=1 to nFields
            cField:=aTargetFieldsDef[nField][1]
            if (oHMTargetStruct:Get(cField,@aField))
                nTargetFieldPos:=aField[1][DBS_ALEN+1]
            else
                nTargetFieldPos:=0
            endif
            aAdd(aTargetFieldsDef[nField],nTargetFieldPos)
        next nField

        oHMTargetStruct:Clean()
        oHMTargetStruct:=FreeObj(oHMTargetStruct)

        oFT:=uft():New()

        MsAguarde({||nft_fHandle:=oFT:ft_fUse(cSourceFile)},"Loading Data File","Wait")
        lImportData:=(nft_fHandle>=0)
        if (!lImportData)
            ApMsgAlert("Could not open the file: "+cSourceFile,"Attention")
            break
        endif

        oFWTemporaryTable:=FWTemporaryTable():New(@cTmpAlias,@aTargetStruct)
        oFWTemporaryTable:AddIndex("01",aAddIndex)
        oFWTemporaryTable:Create()

        cacheData():Set("datasul2totvsprotheus","import"+cTableImport+"Alias",cTmpAlias)
        cacheData():Set("datasul2totvsprotheus","import"+cTableImport+"Table",oFWTemporaryTable:getRealName())

        FWFreeArray(@aField)
        FWFreeArray(@aTargetStruct)

        cFieldFilial:=PrefixoCpo(cAlias)
        cFieldFilial+="_FILIAL"

        lChkFilial:=(allTrim(oTFIni:GetPropertyValue(cAlias,"ChkFilial","1"))=="1")
        if (!lChkFilial)
            cAliasxFilial:=xFilial(cAlias)
        endif

        lChkEncode:=(allTrim(oTFIni:GetPropertyValue(cAlias,"ChkEncode","0"))=="1")

        lSeekTable:=(!empty(cSeekTable:=allTrim(oTFIni:GetPropertyValue(cAlias,"seekTable",""))))
        if (lSeekTable)
            lSeekTable:=chkFile(cSeekTable)
            if (lSeekTable)
                cSeekIndexKey:=allTrim(oTFIni:GetPropertyValue(cAlias,"seekIndexKey",""))
                cSeekTableIndex:=allTrim(oTFIni:GetPropertyValue(cAlias,"seekTableIndex",""))
                nSeekTableIndex:=retOrder(cSeekTable,cSeekTableIndex,.T.)
                lSeekTable:=(nSeekTableIndex>0)
                if (lSeekTable)
                    (cSeekTable)->(dbSetOrder(nSeekTableIndex))
                    cUpdateTableFields:=allTrim(oTFIni:GetPropertyValue(cAlias,"updateTableFields",""))
                    aUpdateTableFields:=strToKArr2(cUpdateTableFields,",")
                    cUpdateTableSource:=allTrim(oTFIni:GetPropertyValue(cAlias,"updateTableSource",""))
                    aUpdateTableSource:=strToKArr2(cUpdateTableSource,",")
                    nUpdateTableSource:=len(aUpdateTableFields)
                    lUpdateTableFields:=(nUpdateTableSource==len(aUpdateTableSource))
                endif
            endif
        endif

        nIncProcStep:=Int(val(allTrim(oTFIni:GetPropertyValue("General","IncProcStep","20"))))
        nIncProcStep:=Min(Max(nIncProcStep,1),100)

        begin sequence

            nRecCount:=oFT:ft_fLastRec()
            cRecCount:=cTools():NToS(nRecCount)
            nRecCountStep:=if(nRecCount>=(nIncProcStep*2),Int(nRecCount/nIncProcStep),nRecCount)
            lRecCountStep:=(nRecCountStep!=nRecCount)
            if (lRecCountStep)
                nRecCountStep+=(nRecCount-(nRecCountStep*nIncProcStep))
            endif
            oMsNewProcess:SetRegua1(nRecCountStep)
            oTimeRemaining:=timeRemaining():New(nRecCountStep)

            oProgress:=txtProgress():New()

            TCSrvMap(cTmpAlias,nil,.F.)

            oFT:ft_fGoTop()
            while (!oFT:ft_fEof())

                nft_fRecNo:=oFT:ft_fRecNo()
                cLine:=oFT:ft_fReadLN()

                begin sequence

                    if (empty(cLine))
                        break
                    endif

                    aLine:=strTokArr2(cLine,";")

                    lAppend:=.T.

                    if (lChkFilial)

                        for nField:=1 to nFields

                            nTargetFieldPos:=aTargetFieldsDef[nField][Len(aTargetFieldsDef[nField])]

                            if (nTargetFieldPos==0)
                                loop
                            endif

                            cField:=aTargetFieldsDef[nField][1]
                            if (cField==cFieldFilial)
                                lHasError:=.F.
                                xValue:=(cTmpAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,aTargetFieldsDef[nField],@aFieldsDef,@oHMSourceFieldsDef))
                                if (lHasError)
                                    cError:=CacheData():Get("EvalBlock","ErrorDescription","")
                                    if (!empty(cError))
                                        aAdd(aLogTitle,"foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]")
                                        nMLCount:=MLCount(cError,nMLCountSize)
                                        for nMLLine:=1 to nMLCount
                                            aAdd(aLog,memoLine(cError,nMLCountSize,nMLLine))
                                        next nMLLine
                                        aAdd(aLogDet,aClone(aLog))
                                        aSize(aLog,0)
                                        lEnd:=oMsNewProcess:lEnd:=.T.
                                        lAppend:=.F.
                                        break
                                    endif
                                endif
                                if (empty(xValue))
                                    if (lHasError)
                                        aAdd(aLogTitle,"foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]")
                                        aAdd(aLog,"Estrutura da Linha diferente da estrutura de Dados")
                                        nMLCount:=MLCount(cLine,nMLCountSize)
                                        for nMLLine:=1 to nMLCount
                                            aAdd(aLog,memoLine(cLine,nMLCountSize,nMLLine))
                                        next nMLLine
                                        aAdd(aLogDet,aClone(aLog))
                                        aSize(aLog,0)
                                    endif
                                    lAppend:=.F.
                                    exit
                                endif
                                SetFilAnt(xValue)
                            endif

                        next nField

                    endif

                    if (lEnd)
                        break
                    endif

                    if (lAppend)

                        if (lChkEncode)
                            cLineUTF8:=DecodeUTF8(cLine)
                            if (empty(cLineUTF8))
                                cLine:=OemToAnsi(cLine)
                                FWFreeArray(@aLine)
                                aLine:=strTokArr2(cLine,";")
                            endif
                            cLineUTF8:=""
                        endif

                        cLine:=""

                        (cTmpAlias)->(dbAppend(.F.))

                            if (lSeekTable)
                                cAllSeekIndexKey:=cSeekIndexKey
                            endif

                            for nField:=1 to nFields

                                nTargetFieldPos:=aTargetFieldsDef[nField][Len(aTargetFieldsDef[nField])]

                                if (nTargetFieldPos==0)
                                    loop
                                endif

                                cField:=aTargetFieldsDef[nField][1]

                                if (lTypeReplicate)
                                    nReplicates:=cacheData():Get("datasul2totvsprotheus",aTargetFieldsDef[nField][2]+"_TypeReplicate",0)
                                    if (nReplicates>0)
                                        lTypeReplicate:=.F.
                                    endif
                                endif

                                if ((!lChkFilial).and.(cField==cFieldFilial))

                                    xValue:=cAliasxFilial

                                else

                                    lHasError:=.F.
                                    xValue:=(cTmpAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,aTargetFieldsDef[nField],@aFieldsDef,@oHMSourceFieldsDef))

                                    if (lHasError)

                                        cError:=CacheData():Get("EvalBlock","ErrorDescription","")

                                        if (!empty(cError))
                                            aAdd(aLogTitle,"foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]")
                                            nMLCount:=MLCount(cError,nMLCountSize)
                                            for nMLLine:=1 to nMLCount
                                                aAdd(aLog,memoLine(cError,nMLCountSize,nMLLine))
                                            next nMLLine
                                            aAdd(aLogDet,aClone(aLog))
                                            aSize(aLog,0)
                                            lEnd:=oMsNewProcess:lEnd:=.T.
                                            lAppend:=.F.
                                            break
                                        endif //(!empty(cError))

                                    endif //(lHasError)

                                endif //((!lChkFilial).and.(cField==cFieldFilial))

                                if (empty(xValue))
                                    if (lHasError)
                                        aAdd(aLogTitle,"foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]")
                                        aAdd(aLog,"Estrutura da Linha diferente da estrutura de Dados")
                                        nMLCount:=MLCount(cLine,nMLCountSize)
                                        for nMLLine:=1 to nMLCount
                                            aAdd(aLog,memoLine(cLine,nMLCountSize,nMLLine))
                                        next nMLLine
                                        aAdd(aLogDet,aClone(aLog))
                                        aSize(aLog,0)
                                        ldbPack:=.T.
                                        (cTmpAlias)->(dbDelete())
                                        exit
                                    endif //(lHasError)
                                    loop
                                endif //(empty(xValue))

                                (cTmpAlias)->(FieldPut(nTargetFieldPos,xValue))

                                if ((lSeekTable).and.(!empty(cAllSeekIndexKey)))
                                    if (cField$cAllSeekIndexKey)
                                        cAllSeekIndexKey:=cTools():StrReplace(cAllSeekIndexKey,{cField,""})
                                    endif
                                    if (empty(cTools():StrReplace(cAllSeekIndexKey,{"+",""})))
                                        cAllSeekIndexKey:=""
                                        (cSeekTable)->(MsSeek((cTmpAlias)->(&(cSeekIndexKey)),.F.))
                                    endif
                                endif

                            next nField

                            if (lSeekTable)

                                if (cSeekTable)->(MsSeek((cTmpAlias)->(&(cSeekIndexKey)),.F.))

                                    if ((lUpdateTableFields).and.(cSeekTable)->(recLock(cSeekTable,.F.)))

                                        for nField:=1 to nUpdateTableSource

                                            cField:=aUpdateTableSource[nField]
                                            nTargetFieldPos:=aScan(aTargetFieldsDef,{|e|(e[1]==cField)})

                                            if (nTargetFieldPos>0)

                                                lHasError:=.F.
                                                xValue:=(cTmpAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,aTargetFieldsDef[nTargetFieldPos],@aFieldsDef,@oHMSourceFieldsDef,@cType))

                                                if (lHasError)

                                                    cError:=CacheData():Get("EvalBlock","ErrorDescription","")
                                                    if (!empty(cError))
                                                        aAdd(aLogTitle,"foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]")
                                                        nMLCount:=MLCount(cError,nMLCountSize)
                                                        for nMLLine:=1 to nMLCount
                                                            aAdd(aLog,memoLine(cError,nMLCountSize,nMLLine))
                                                        next nMLLine
                                                        aAdd(aLogDet,aClone(aLog))
                                                        aSize(aLog,0)
                                                        lEnd:=oMsNewProcess:lEnd:=.T.
                                                        break
                                                    endif //(!empty(cError))

                                                endif //(lHasError)

                                                cField:=aUpdateTableFields[nField]
                                                xValue:=NormalizeData(@lHasError,xValue,cType,cField,.T.,@st_oHMbTransform,@oTFIni)

                                                if (lHasError)

                                                    cError:=CacheData():Get("EvalBlock","ErrorDescription","")

                                                    if (!empty(cError))
                                                        aAdd(aLogTitle,"foram Encontradas inconsistencias na linha ["+cTools():NToS(nft_fRecNo)+"]")
                                                        nMLCount:=MLCount(cError,nMLCountSize)
                                                        for nMLLine:=1 to nMLCount
                                                            aAdd(aLog,memoLine(cError,nMLCountSize,nMLLine))
                                                        next nMLLine
                                                        aAdd(aLogDet,aClone(aLog))
                                                        aSize(aLog,0)
                                                        lEnd:=oMsNewProcess:lEnd:=.T.
                                                        (cSeekTable)->(MsUnLock())
                                                        break
                                                    endif //(!empty(cError))

                                                endif //(lHasError)

                                            endif //(nTargetFieldPos>0)

                                            (cSeekTable)->(FieldPut(FieldPos(cField),xValue))

                                        next nField

                                        (cSeekTable)->(MsUnLock())

                                    endif //((lUpdateTableFields).and.(cSeekTable)->(recLock(cSeekTable,.F.)))

                                endif //(cSeekTable)->(MsSeek((cTmpAlias)->(&(cSeekIndexKey)),.F.))

                            endif //(lSeekTable)

                        ldbCommit:=(++nCommitBuffer>=1024)

                        if (nReplicates>0)

                            aReplicate:=(cTmpAlias)->(aUtils():RegToArray())
                            nReplicate:=2
                        
                            while (nReplicate<=nReplicates)

                                (cTmpAlias)->(dbAppend(.F.))

                                    for nField:=1 to nFields

                                        nTargetFieldPos:=aTargetFieldsDef[nField][Len(aTargetFieldsDef[nField])]

                                        if (nTargetFieldPos==0)
                                            loop
                                        endif

                                        cField:=aTargetFieldsDef[nField][1]

                                        if (cacheData():Get("datasul2totvsprotheus",aTargetFieldsDef[nField][2]+"_TypeReplicate",0)>0)

                                            aTargetFieldsDefReplicate:=aClone(aTargetFieldsDef[nField])
                                            aTargetFieldsDefReplicate[2]+=cTools():NToS(nReplicate)
                                            xValue:=(cTmpAlias)->(getTargetFieldValue(@lHasError,@oTFIni,@aLine,@cField,@aTargetFieldsDefReplicate,@aFieldsDef,@oHMSourceFieldsDef))

                                            FWFreeArray(@aTargetFieldsDefReplicate)

                                        else

                                            xValue:=aReplicate[nTargetFieldPos]

                                        endif

                                        (cTmpAlias)->(FieldPut(nTargetFieldPos,xValue))

                                    next nField

                                ldbCommit:=(++nCommitBuffer>=1024)

                                nReplicate++

                            end while

                            FwFreeArray(@aReplicate)

                        endif

                    endif

                    FWFreeArray(@aLine)

                end sequence

                nRecProc++
                if ((!lRecCountStep).or.(Mod(nRecProc,nIncProcStep)==0).or.(nRecProc>=nRecCount))
                    oTimeRemaining:Calcule(.T.)
                    cTimeRemaining:=" :: End of processing in ["+oTimeRemaining:GetcTRemaining()+"]["+DtoC(oTimeRemaining:GetdEndTime())+"]"
                    cTimeRemaining+="["+oTimeRemaining:GetcEndTime()+"]"
                    cTimeRemaining+="["+oTimeRemaining:GetcAverageTime()+"]"
                    cIncProc:="["+oProgress:Eval()+"] "
                    cIncProc+="Processing Record: "
                    cIncProc+=cTools():NToS(nft_fRecNo)
                    cIncProc+="/"
                    cIncProc+=cRecCount
                    cIncProc+=cTimeRemaining
                    cIncProc+="::["+cTools():NToS(if((nRecProc>=nRecCount),100,((nRecProc/nRecCount)*100)))+"%]"
                    oMsNewProcess:IncRegua1(cIncProc)
                endif

                lEnd:=oMsNewProcess:lEnd

                if (lEnd)
                    aAdd(aLogTitle,"Process canceled by user")
                    aAdd(aLog,"Process canceled by user ["+DtoC(Date())+"]["+Time()+"]")
                    aAdd(aLogDet,aClone(aLog))
                    aSize(aLog,0)
                    exit
                endif

                if (ldbCommit)
                    nCommitBuffer:=0
                    (cTmpAlias)->(dbCommitAll())
                endif

                oFT:ft_fDelete()
                oFT:ft_fSkip()

            end while

            if (nCommitBuffer>0)
                (cTmpAlias)->(dbCommitAll())
            endif

            oFT:ft_fUse()

            if (lEnd)
                break
            endif

            if (ldbPack)
                MsAguarde({||(cTmpAlias)->(__dbPack())})
            endif

            nRecCount:=(cTmpAlias)->(recCount())
            cRecCount:=cTools():NToS(nRecCount)
            nRecCountStep:=if(nRecCount>=(nIncProcStep*2),Int(nRecCount/nIncProcStep),nRecCount)
            lRecCountStep:=(nRecCountStep!=nRecCount)
            if (lRecCountStep)
                nRecCountStep+=(nRecCount-(nRecCountStep*nIncProcStep))
            endif
            oMsNewProcess:SetRegua2(nRecCountStep)
            oTimeRemaining:SetRemaining(nRecCountStep)

            (cAlias)->(dbSetOrder(nIndexKey))

            nRecProc:=0

            lAppendIfNotExist:=(allTrim(oTFIni:GetPropertyValue(cTableImport,"AppendIfNotExist","1"))=="1")

            (cTmpAlias)->(dbGoTop())
            while (cTmpAlias)->(!eof())
                cIndexID:=(cTmpAlias)->(&(cIndexKey))
                lFound:=(cAlias)->(dbSeek(cIndexID,.F.))
                begin sequence
                    if ((!lFound).and.(!lAppendIfNotExist))
                        break
                    endif
                    lAddNew:=(!lFound)
                    if ((cAlias)->(recLock(cAlias,lAddNew)))
                        for nField:=1 to nFields
                            nTargetFieldPos:=aTargetFieldsDef[nField][Len(aTargetFieldsDef[nField])]
                            if (nTargetFieldPos==0)
                                loop
                            endif
                            cField:=aTargetFieldsDef[nField][1]
                            if ((lFound).and.(cField$cIndexKey))
                                loop
                            endif
                            xValue:=(cTmpAlias)->(FieldGet(nTargetFieldPos))
                            if (empty(xValue))
                                loop
                            endif
                            (cAlias)->(FieldPut(nTargetFieldPos,xValue))
                        next nField
                        if (cAlias=="SRA")
                            if (empty((cAlias)->RA_CODUNIC))
                                if (st_lfRACodUnic)
                                    (cAlias)->RA_CODUNIC:=fRACodUnic()
                                endif
                            endif
                        endif
                        (cAlias)->(msUnLock())
                    endif
                end sequence
                nRecProc++
                if ((!lRecCountStep).or.(Mod(nRecProc,nIncProcStep)==0).or.(nRecProc>=nRecCount))
                    oTimeRemaining:Calcule(.T.)
                    cTimeRemaining:=" :: End of processing in ["+oTimeRemaining:GetcTRemaining()+"]["+DtoC(oTimeRemaining:GetdEndTime())+"]"
                    cTimeRemaining+="["+oTimeRemaining:GetcEndTime()+"]"
                    cTimeRemaining+="["+oTimeRemaining:GetcAverageTime()+"]"
                    cIncProc:="["+oProgress:Eval()+"] "
                    cIncProc+="Updating Record: "
                    cIncProc+=cTools():NToS(nRecProc)
                    cIncProc+="/"
                    cIncProc+=cRecCount
                    cIncProc+=cTimeRemaining
                    cIncProc+="::["+cTools():NToS(if((nRecProc>=nRecCount),100,((nRecProc/nRecCount)*100)))+"%]"
                    oMsNewProcess:IncRegua2(cIncProc)
                endif
                lEnd:=oMsNewProcess:lEnd
                if (lEnd)
                    aAdd(aLogTitle,"Process canceled by user")
                    aAdd(aLog,"Process canceled by user ["+DtoC(Date())+"]["+Time()+"]")
                    aAdd(aLogDet,aClone(aLog))
                    aSize(aLog,0)
                    exit
                endif
                (cTmpAlias)->(dbSkip())
            end while

            if (lEnd)
                break
            endif

        end sequence

        (cTmpAlias)->(dbCloseArea())

        oFWTemporaryTable:Delete()
        oFWTemporaryTable:=FreeObj(oFWTemporaryTable)

    end sequence

    FWFreeArray(@aLog)

    SetFilAnt(cSVFilAnt)

    CacheData():delSection("EvalBlock")

    if (valtype(oHMSourceFieldsDef)=="O")
        oHMSourceFieldsDef:Clean()
        oHMSourceFieldsDef:=FreeObj(oHMSourceFieldsDef)
    endif

    if (valType(aTargetStruct)=="A")
        FWFreeArray(@aTargetStruct)
    endif

    if (valType(aFieldsDef)=="A")
        FWFreeArray(@aFieldsDef)
    endif

    if (valType(aTargetFieldsDef)=="A")
        FWFreeArray(@aTargetFieldsDef)
    endif

return(lImportData)

static function importSRA(oMsNewProcess as object,lEnd as logical) as logical

    local aLogDet:=array(0) as array
    local aLogTitle:=array(0) as array

    local cAlias:="SRA" as character
    local cIndexKey:="RA_FILIAL+RA_MAT" as character
    local cTableImport:="SRA" as character
    local aAddIndex:={"RA_FILIAL","RA_MAT"} as array

    local lImportSRA as logical

    lImportSRA:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)

    if ((lImportSRA).and.(!lEnd))
        oMsNewProcess:SetRegua1(0)
        oMsNewProcess:IncRegua1("Wait!")
        oMsNewProcess:SetRegua2(0)
        oMsNewProcess:IncRegua2("...")
        cIndexKey:="RA_MATMIG"
        cTableImport:="SRA_RHPF"
        FWFreeArray(@aAddIndex)
        aAddIndex:={"RA_MATMIG"}
        lImportSRA:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)
        if (lImportSRA)
            ApMsgInfo("SRA Table Import Completed","Info")
        else
            ApMsgInfo("Problems were encountered while processing the SRA_RHPF table","Info")
        endif
    endif

    if (!empty(aLogDet))
        fMakeLog(aLogDet,aLogTitle,nil,nil,ProcName(),"Log de Ocorrencias na Importacao","G","L",nil,.F.)
    endif

    FWFreeArray(@aLogDet)
    FWFreeArray(@aLogTitle)
    FWFreeArray(@aAddIndex)

return(lImportSRA)

static function importSRB(oMsNewProcess as object,lEnd as logical) as logical

    local aLogDet:=array(0) as array
    local aLogTitle:=array(0) as array

    local cAlias:="SRB" as character
    local cIndexKey:="RB_FILIAL+RB_MAT+RB_COD" as character
    local cTableImport:="SRB" as character
    local aAddIndex:={"RB_FILIAL","RB_MAT","RB_COD"} as array

    local lImportSRB as logical

    lImportSRB:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)

    if (lImportSRB)
        ApMsgInfo("SRB Table Import Completed","Info")
    else
        ApMsgInfo("Problems were encountered while processing the SRB table","Info")
    endif

    if (!empty(aLogDet))
        fMakeLog(aLogDet,aLogTitle,nil,nil,ProcName(),"Log de Ocorrencias na Importacao","G","L",nil,.F.)
    endif

    FWFreeArray(@aLogDet)
    FWFreeArray(@aLogTitle)
    FWFreeArray(@aAddIndex)

return(lImportSRB)

static function importSRD(oMsNewProcess as object,lEnd as logical) as logical

    local aLogDet:=array(0) as array
    local aLogTitle:=array(0) as array

    local cAlias:="SRD" as character
    local cIndexKey:="RD_FILIAL+RD_MAT+RD_CC+RD_ITEM+RD_CLVL+RD_DATARQ+RD_PD+RD_SEQ+RD_PERIODO+RD_SEMANA+RD_ROTEIR+DTOS(RD_DTREF)+RD_CONVOC+RD_NRBEN" as character
    local cTableImport:="SRD" as character
    local aAddIndex:={"RD_FILIAL","RD_MAT","RD_CC","RD_ITEM","RD_CLVL","RD_DATARQ","RD_PD","RD_SEQ","RD_PERIODO","RD_SEMANA","RD_ROTEIR","RD_DTREF","RD_CONVOC","RD_NRBEN"} as array

    local lImportSRD as logical

    lImportSRD:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)

    if (lImportSRD)
        ApMsgInfo("SRD Table Import Completed","Info")
    else
        ApMsgInfo("Problems were encountered while processing the SRD table","Info")
    endif

    if (!empty(aLogDet))
        fMakeLog(aLogDet,aLogTitle,nil,nil,ProcName(),"Log de Ocorrencias na Importacao","G","L",nil,.F.)
    endif

    FWFreeArray(@aLogDet)
    FWFreeArray(@aLogTitle)
    FWFreeArray(@aAddIndex)

return(lImportSRD)

static function importSRF(oMsNewProcess as object,lEnd as logical) as logical

    local aLogDet:=array(0) as array
    local aLogTitle:=array(0) as array

    local cAlias:="SRF" as character
    local cIndexKey:="RF_FILIAL+RF_MAT+DTOS(RF_DATABAS)+RF_PD" as character
    local cTableImport:="SRF" as character
    local aAddIndex:={"RF_FILIAL","RF_MAT","RF_DATABAS","RF_PD"} as array

    local lImportSRF as logical

    lImportSRF:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)

    if (lImportSRF)
        ApMsgInfo("SRF Table Import Completed","Info")
    else
        ApMsgInfo("Problems were encountered while processing the SRF table","Info")
    endif

    if (!empty(aLogDet))
        fMakeLog(aLogDet,aLogTitle,nil,nil,ProcName(),"Log de Ocorrencias na Importacao","G","L",nil,.F.)
    endif

    FWFreeArray(@aLogDet)
    FWFreeArray(@aLogTitle)
    FWFreeArray(@aAddIndex)

return(lImportSRF)

static function importSR3(oMsNewProcess as object,lEnd as logical) as logical

    local aLogDet:=array(0) as array
    local aLogTitle:=array(0) as array

    local cAlias:="SR3" as character
    local cIndexKey:="R3_FILIAL+R3_MAT+DTOS(R3_DATA)+R3_SEQ+R3_TIPO+R3_PD" as character
    local cTableImport:="SR3" as character
    local aAddIndex:={"R3_FILIAL","R3_MAT","R3_DATA","R3_SEQ","R3_TIPO","R3_PD"} as array

    local lImportSR3 as logical

    lImportSR3:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)

    if ((lImportSR3).and.(!lEnd))
        oMsNewProcess:SetRegua1(0)
        oMsNewProcess:IncRegua1("Wait!")
        oMsNewProcess:SetRegua2(0)
        oMsNewProcess:IncRegua2("...")
        cAlias:="SR7"
        cIndexKey:="R7_FILIAL+R7_MAT+DTOS(R7_DATA)+R7_SEQ+R7_TIPO"
        cTableImport:="SR7"
        FWFreeArray(@aAddIndex)
        aAddIndex:={"R7_FILIAL","R7_MAT","R7_DATA","R7_SEQ","R7_TIPO"}
        lImportSR3:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)
        if (lImportSR3)
            ApMsgInfo("SR3/SR7 Table Import Completed","Info")
        else
            ApMsgInfo("Problems were encountered while processing the SR7 table","Info")
        endif
    endif

    if (!empty(aLogDet))
        fMakeLog(aLogDet,aLogTitle,nil,nil,ProcName(),"Log de Ocorrencias na Importacao","G","L",nil,.F.)
    endif

    FWFreeArray(@aLogDet)
    FWFreeArray(@aLogTitle)
    FWFreeArray(@aAddIndex)

return(lImportSR3)

static function importSR8(oMsNewProcess as object,lEnd as logical) as logical

    local aLogDet:=array(0) as array
    local aLogTitle:=array(0) as array

    local cAlias:="SR8" as character
    local cIndexKey:="R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO" as character
    local cTableImport:="SR8" as character
    local aAddIndex:={"R8_FILIAL","R8_MAT","R8_DATAINI","R8_TIPO","R8_TIPOAFA"} as array

    local lImportSR8 as logical

    lImportSR8:=ImportData(@oMsNewProcess,@lEnd,@aLogDet,@aLogTitle,@cAlias,@cIndexKey,@cTableImport,@aAddIndex)

    if (lImportSR8)
        ApMsgInfo("SR8 Table Import Completed","Info")
    else
        ApMsgInfo("Problems were encountered while processing the SR8 table","Info")
    endif

    if (!empty(aLogDet))
        fMakeLog(aLogDet,aLogTitle,nil,nil,ProcName(),"Log de Ocorrencias na Importacao","G","L",nil,.F.)
    endif

    FWFreeArray(@aLogDet)
    FWFreeArray(@aLogTitle)
    FWFreeArray(@aAddIndex)

return(lImportSR8)
